
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o cforth.prg -L cforth.lst main.asm
; Thu Oct 10 19:32:45 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: compiler/data.asm

=32					STACKSIZE = 32 								; maximum data stack depth
=40					BUFFERSIZE = 40 							; word buffer size
=$00					COL_COMMENT = $00 							; White (comment)
=$40					COL_DEFINE = $40 							; Red (defining word)
=$80					COL_COMPILE = $80 							; Green (compiling word)
=$c0					COL_EXEC = $C0 								; Yellow (executing word)
=$01					DTP_IMMEDIATE = $01 						; Bit 0 type (immediate, cannot be executed)
=$02					DTP_COMPILEONLY = $02 						; Bit 1 type (cannot be execute, only compiled)
>0010					zTemp0: .word ?								; temporary page zero pointers
>0012					zTemp1: .word ? 							; these must be consecutive.
>0014					freeDictionary: .word ? 					; current end of dictionary address
>0016					freeCode: .word ? 							; next free code byte.
>0018					freeCodeBank: .byte ?						; next free code byte bank (byte())
>0019					newDictRecord: .word ? 						; address of created dictionary record.
>001b					bufferPtr: .word ? 							; buffer pointer
>0800					lStack: .fill STACKSIZE						; low and high byte stack areas. Note that
>0820					hStack: .fill STACKSIZE						; these do not have to be in page zero, it just
>0a00					dictAddr: .word ? 							; these are copied when a search is successful
>0a02					dictBank: .byte ? 							; (must be consecutive)
>0a03					dictType: .byte ?
>0a04					wordType: .byte ?							; type of word in buffer
>0a05					SearchBuffer: .fill BUFFERSIZE				; buffer for word for compiler
>0a2d					InputBuffer: .fill BUFFERSIZE 				; input buffer
>0a55					ErrorBuffer: .fill BUFFERSIZE 				; error message buffer
>0a7d					CurrentTOS: .word ? 						; current stack top value
>0a7f					CurrentIndex: .byte ? 						; current index value.
>0a80					DefaultStackPointer: .byte ? 				; default value 6502 stack pointer.
>0a81					SCWidth: .byte ? 							; width
>0a82					SCHeight:.byte ?							; height
>0a83					SCX: .byte ?								; screen position
>0a84					SCY: .byte ?
>0a85					SCColour: .byte ?							; drawing colour

;******  Return to file: main.asm


;******  Processing file: layouts/simple.inc

=$1000					DictionaryBase = $1000						; Dictionary address
=$2000					CodeSpace = $2000							; Code start position.
=$a000					BuildAddress = $A000 						; where the binary is built

;******  Return to file: main.asm

.a000	ba		tsx				tsx 								; save entry SP
.a001	8e 80 0a	stx $0a80			stx 	DefaultStackPointer
.a004	4c a6 a0	jmp $a0a6			jmp 	ColdStart

;******  Processing file: compiler/dictionary.asm

.a007					DictionaryReset:
.a007	80 06		bra $a00f			bra 	XDictionaryReset
.a009					DictionarySearch:
.a009	80 20		bra $a02b			bra 	XDictionarySearch
.a00b					DictionaryCreate:
.a00b	80 5b		bra $a068			bra 	XDictionaryCreate
.a00d					DictionaryXorTypeByte:
.a00d	80 50		bra $a05f			bra 	XDictionaryXorTypeByte
.a00f					XDictionaryReset:
.a00f	48		pha				pha
.a010	a9 00		lda #$00			lda 	#0 							; reset the next free code byte position.
.a012	85 18		sta $18				sta 	freeCodeBank
.a014	a9 00		lda #$00			lda 	#CodeSpace & $FF
.a016	85 16		sta $16				sta 	freeCode
.a018	a9 20		lda #$20			lda 	#CodeSpace >> 8
.a01a	85 17		sta $17				sta 	freeCode+1
.a01c	a9 00		lda #$00			lda 	#0
.a01e	8d 00 10	sta $1000			sta 	DictionaryBase
.a021	a9 00		lda #$00			lda 	#DictionaryBase & $FF 		; set the next free byte pointer
.a023	85 14		sta $14				sta 	freeDictionary
.a025	a9 10		lda #$10			lda 	#DictionaryBase >> 8
.a027	85 15		sta $15				sta 	freeDictionary+1
.a029	68		pla				pla
.a02a	60		rts				rts
.a02b					XDictionarySearch:
.a02b					_XDSLoop:
.a02b	b2 10		lda ($10)			lda 	(zTemp0)					; look at length
.a02d	18		clc				clc 								; clear carry, return CC if failed.
.a02e	f0 2c		beq $a05c			beq		_XDSExit					; exit ?
.a030	a0 05		ldy #$05			ldy 	#5 							; where comparison starts in dictionary
.a032	a2 00		ldx #$00			ldx 	#0 							; comparison starts in SearchBuffer
.a034					_XDSCompare:
.a034	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x 				; compare characters
.a037	d1 10		cmp ($10),y			cmp 	(zTemp0),y
.a039	d0 14		bne $a04f			bne 	_XDSNext 					; did not match, try next.
.a03b	e8		inx				inx 								; advance pointers
.a03c	c8		iny				iny
.a03d	0a		asl a				asl 	a 							; shift bit 7 into Carry
.a03e	90 f4		bcc $a034			bcc 	_XDSCompare 				; found it !
.a040	a0 01		ldy #$01			ldy 	#1 							; copy 1,2,3,4 to zTemp
.a042					_XDSCopy:
.a042	b1 10		lda ($10),y			lda 	(zTemp0),y
.a044	99 ff 09	sta $09ff,y			sta 	dictAddr-1,y
.a047	c8		iny				iny
.a048	c0 05		cpy #$05			cpy 	#5
.a04a	d0 f6		bne $a042			bne 	_XDSCopy
.a04c	38		sec				sec 								; return CS
.a04d	80 0d		bra $a05c			bra 	_XDSExit
.a04f					_XDSNext:
.a04f	18		clc				clc 								; add offset to zTemp0
.a050	a5 10		lda $10				lda 	zTemp0
.a052	72 10		adc ($10)			adc 	(zTemp0)
.a054	85 10		sta $10				sta 	zTemp0
.a056	90 d3		bcc $a02b			bcc 	_XDSLoop 					; no carry
.a058	e6 11		inc $11				inc 	zTemp0+1 					; carry forward.
.a05a	80 cf		bra $a02b			bra 	_XDSLoop
.a05c					_XDSExit:
.a05c	08		php				php									; switch bank bank, preserving carry.
.a05d	28		plp				plp
.a05e	60		rts				rts
.a05f					XDictionaryXorTypeByte:
.a05f	5a		phy				phy
.a060	a0 04		ldy #$04			ldy 	#4 							; offset to type
.a062	51 19		eor ($19),y			eor 	(newDictRecord),y
.a064	91 19		sta ($19),y			sta 	(newDictRecord),y
.a066	7a		ply				ply
.a067	60		rts				rts
.a068					XDictionaryCreate:
.a068	a5 14		lda $14				lda 	freeDictionary 				; copy address to new dictionary record pointer
.a06a	85 19		sta $19				sta 	newDictRecord
.a06c	a5 15		lda $15				lda 	freeDictionary+1
.a06e	85 1a		sta $1a				sta 	newDictRecord+1
.a070	a0 05		ldy #$05			ldy 	#5 							; copy the name in, also calculates offset
.a072	a2 00		ldx #$00			ldx 	#0
.a074					_XDCCopyName:
.a074	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x 				; copy over name
.a077	91 14		sta ($14),y			sta 	(freeDictionary),y
.a079	e8		inx				inx
.a07a	c8		iny				iny
.a07b	0a		asl a				asl 	a 							; until bit 7 is copied.
.a07c	90 f6		bcc $a074			bcc 	_XDCCopyName
.a07e	98		tya				tya 								; Y is now offset to next
.a07f	92 14		sta ($14)			sta 	(freeDictionary)
.a081	a0 01		ldy #$01			ldy 	#1 							; copy code address & bank in.
.a083	a5 16		lda $16				lda 	freeCode
.a085	91 14		sta ($14),y			sta 	(freeDictionary),y
.a087	c8		iny				iny
.a088	a5 17		lda $17				lda 	freeCode+1
.a08a	91 14		sta ($14),y			sta 	(freeDictionary),y
.a08c	c8		iny				iny
.a08d	a5 18		lda $18				lda 	freeCodeBank
.a08f	91 14		sta ($14),y			sta 	(freeDictionary),y
.a091	c8		iny				iny
.a092	a9 00		lda #$00			lda 	#0 							; set the type byte to zero.
.a094	91 14		sta ($14),y			sta 	(freeDictionary),y
.a096	18		clc				clc 								; adjust freedictionary ptr up
.a097	a5 14		lda $14				lda 	freeDictionary
.a099	72 14		adc ($14)			adc 	(freeDictionary)
.a09b	85 14		sta $14				sta 	freeDictionary
.a09d	90 02		bcc $a0a1			bcc 	_XDCNoCarry
.a09f	e6 15		inc $15				inc 	freeDictionary+1
.a0a1					_XDCNoCarry:
.a0a1	a9 00		lda #$00			lda 	#0 							; write end of dictionary marker
.a0a3	92 14		sta ($14)			sta 	(freeDictionary)
.a0a5	60		rts				rts

;******  Return to file: main.asm

.a0a6					ColdStart:
.a0a6	ae 80 0a	ldx $0a80			ldx 	DefaultStackPointer 		; reset the stack pointer
.a0a9	9a		txs				txs
.a0aa	20 07 a0	jsr $a007			jsr 	DictionaryReset
.a0ad	20 f4 a4	jsr $a4f4			jsr 	System_ResetStack 			; clear stack.
.a0b0	8e 7f 0a	stx $0a7f			stx 	CurrentIndex 				; save that state in 'current' variables
.a0b3	8d 7d 0a	sta $0a7d			sta 	CurrentTOS 					; which is X (stack) and YA (top of stack)
.a0b6	8c 7e 0a	sty $0a7e			sty 	CurrentTOS+1
.a0b9	9c 55 0a	stz $0a55			stz 	ErrorBuffer 				; clear the error buffer.
.a0bc	20 cc a0	jsr $a0cc			jsr 	XClearScreen
.a0bf	4c 74 a1	jmp $a174			jmp 	CommandLine

;******  Processing file: compiler/macros.inc


;******  Return to file: main.asm


;******  Processing file: system/extern.asm

=$9f20					Vera_Lo = $9F20
=$9f21					Vera_Mid = $9F21
=$9f22					Vera_High = $9F22
=$9f23					Vera_Data = $9F23
.a0c2					XGetKey:
.a0c2	da		phx				phx
.a0c3	5a		phy				phy
.a0c4					_XGetKey:
.a0c4	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.a0c7	f0 fb		beq $a0c4			beq 	_XGetKey
.a0c9	7a		ply				ply
.a0ca	fa		plx				plx
.a0cb	60		rts				rts
.a0cc					XClearScreen:
.a0cc	48		pha				pha
.a0cd	da		phx				phx
.a0ce	5a		phy				phy
.a0cf	a9 0e		lda #$0e			lda 	#14 						; switch to l/c
.a0d1	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a0d4	a9 01		lda #$01			lda 	#$01 						; set fractional scale to 2
.a0d6	8d 20 9f	sta $9f20			sta 	Vera_Lo
.a0d9	9c 21 9f	stz $9f21			stz 	Vera_Mid
.a0dc	a9 1f		lda #$1f			lda 	#$1F
.a0de	8d 22 9f	sta $9f22			sta 	Vera_High
.a0e1	a9 40		lda #$40			lda		#64
.a0e3	8d 23 9f	sta $9f23			sta 	Vera_Data
.a0e6	8d 23 9f	sta $9f23			sta 	Vera_Data
.a0e9	a9 28		lda #$28			lda 	#40 						; set size and current draw colour
.a0eb	8d 81 0a	sta $0a81			sta 	SCWidth
.a0ee	a9 1e		lda #$1e			lda 	#30
.a0f0	8d 82 0a	sta $0a82			sta 	SCHeight
.a0f3	a9 01		lda #$01			lda 	#1
.a0f5	8d 85 0a	sta $0a85			sta 	SCColour
.a0f8	9c 20 9f	stz $9f20			stz 	Vera_Lo 					; clear memory to spaces
.a0fb	9c 21 9f	stz $9f21			stz 	Vera_Mid
.a0fe	a9 10		lda #$10			lda 	#$10
.a100	8d 22 9f	sta $9f22			sta 	Vera_High
.a103	ad 82 0a	lda $0a82			lda 	SCHeight
.a106	4a		lsr a				lsr 	a
.a107	a8		tay				tay
.a108	a2 00		ldx #$00			ldx 	#0
.a10a					_XCSLoop:
.a10a	a9 20		lda #$20			lda 	#$20
.a10c	8d 23 9f	sta $9f23			sta 	Vera_Data
.a10f	9c 23 9f	stz $9f23			stz 	Vera_Data
.a112	ca		dex				dex
.a113	d0 f5		bne $a10a			bne 	_XCSLoop
.a115	88		dey				dey
.a116	d0 f2		bne $a10a			bne 	_XCSLoop
.a118	7a		ply				ply
.a119	fa		plx				plx
.a11a	68		pla				pla 								; fall through to home
.a11b					XHomeCursor:
.a11b	9c 83 0a	stz $0a83			stz 	SCX
.a11e	9c 84 0a	stz $0a84			stz 	SCY
.a121	60		rts				rts
.a122					XGetCursor:
.a122	ae 83 0a	ldx $0a83			ldx 	SCX
.a125	ac 84 0a	ldy $0a84			ldy 	SCY
.a128	60		rts				rts
.a129					XSetCursor:
.a129	8e 83 0a	stx $0a83			stx 	SCX
.a12c	8c 84 0a	sty $0a84			sty 	SCY
.a12f	60		rts				rts
.a130	48		pha		XPrint:	pha
.a131	48		pha				pha
.a132	ad 83 0a	lda $0a83			lda 	SCX 						; 2 bytes / char
.a135	0a		asl a				asl 	a
.a136	8d 20 9f	sta $9f20			sta 	Vera_Lo 					; low address
.a139	ad 84 0a	lda $0a84			lda 	SCY
.a13c	8d 21 9f	sta $9f21			sta 	Vera_Mid 					; mid address
.a13f	a9 10		lda #$10			lda 	#$10
.a141	8d 22 9f	sta $9f22			sta 	Vera_High
.a144	68		pla				pla 								; characters are PETSCII
.a145	29 bf		and #$bf			and 	#$BF
.a147	8d 23 9f	sta $9f23			sta		Vera_Data
.a14a	ad 85 0a	lda $0a85			lda 	SCColour
.a14d	8d 23 9f	sta $9f23			sta 	Vera_Data
.a150	ee 83 0a	inc $0a83			inc 	SCX 						; one right
.a153	ad 83 0a	lda $0a83			lda 	SCX
.a156	cd 81 0a	cmp $0a81			cmp 	SCWidth 					; reached RHS
.a159	d0 03		bne $a15e			bne 	_XPR0
.a15b	20 60 a1	jsr $a160			jsr 	XNewLine 					; yes, do a new line
.a15e					_XPR0:
.a15e	68		pla				pla
.a15f	60		rts				rts
.a160					XNewLine:
.a160	48		pha				pha
.a161	9c 83 0a	stz $0a83			stz 	SCX 						; start of line
.a164	ee 84 0a	inc $0a84			inc 	SCY 						; next line down
.a167	ad 84 0a	lda $0a84			lda 	SCY 						; wrap around the bottom.
.a16a	cd 82 0a	cmp $0a82			cmp 	SCHeight
.a16d	d0 03		bne $a172			bne 	_XNL0
.a16f	9c 84 0a	stz $0a84			stz 	SCY
.a172	68		pla		_XNL0:	pla
.a173	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: compiler/cli.asm

.a174					CommandLine:
.a174	ae 80 0a	ldx $0a80			ldx 	DefaultStackPointer 		; reset the stack pointer
.a177	9a		txs				txs		;
.a178	a9 03		lda #$03			lda 	#3 							; erase bottom 3 lines.
.a17a	20 62 a2	jsr $a262			jsr 	CLMove
.a17d					_CLIErase:
.a17d	a9 20		lda #$20			lda 	#' '
.a17f	20 30 a1	jsr $a130			jsr 	XPrint
.a182	20 22 a1	jsr $a122			jsr 	XGetCursor
.a185	98		tya				tya
.a186	d0 f5		bne $a17d			bne 	_CLIErase
.a188	a9 02		lda #$02			lda 	#2 							; 2 up from the bottom is the
.a18a	20 62 a2	jsr $a262			jsr 	CLMove 						; stack display area.
.a18d	a9 03		lda #$03			lda 	#3 							; cyan
.a18f	8d 85 0a	sta $0a85			sta 	SCColour
.a192	ad 7f 0a	lda $0a7f			lda 	CurrentIndex 				; display stack elements
.a195	f0 15		beq $a1ac			beq 	_CLIEndStack
.a197	c9 ff		cmp #$ff			cmp 	#$FF
.a199	f0 11		beq $a1ac			beq 	_CLIEndStack
.a19b	a2 00		ldx #$00			ldx 	#0 							; stacked elements.
.a19d					_CLIPrintStack:
.a19d	e8		inx				inx
.a19e	bd 00 08	lda $0800,x			lda 	lStack,x
.a1a1	bc 20 08	ldy $0820,x			ldy 	hStack,x
.a1a4	20 6e a2	jsr $a26e			jsr 	CLPrint
.a1a7	ec 7f 0a	cpx $0a7f			cpx 	CurrentIndex
.a1aa	d0 f1		bne $a19d			bne 	_CLIPrintStack
.a1ac					_CLIEndStack:
.a1ac	ad 7f 0a	lda $0a7f			lda 	CurrentIndex
.a1af	c9 ff		cmp #$ff			cmp 	#$FF
.a1b1	f0 09		beq $a1bc			beq 	_CLIEmptyStack
.a1b3	ad 7d 0a	lda $0a7d			lda 	CurrentTOS 					; the YA in its saved slot
.a1b6	ac 7e 0a	ldy $0a7e			ldy 	CurrentTOS+1
.a1b9	20 6e a2	jsr $a26e			jsr 	CLPrint
.a1bc					_CLIEmptyStack:
.a1bc	a9 04		lda #$04			lda 	#4 							; colour
.a1be	8d 85 0a	sta $0a85			sta 	SCColour
.a1c1	ad 55 0a	lda $0a55			lda 	ErrorBuffer 				; check empty
.a1c4	d0 0d		bne $a1d3			bne 	_CLIHasMsg
.a1c6	a9 0f		lda #$0f			lda 	#"O" & $3F 					; if so show "ok"
.a1c8	8d 55 0a	sta $0a55			sta 	ErrorBuffer
.a1cb	a9 0b		lda #$0b			lda 	#"K" & $3F
.a1cd	8d 56 0a	sta $0a56			sta 	ErrorBuffer+1
.a1d0	9c 57 0a	stz $0a57			stz 	ErrorBuffer+2
.a1d3					_CLIHasMsg:
.a1d3	a9 01		lda #$01			lda 	#1 							; position cursor
.a1d5	20 62 a2	jsr $a262			jsr 	CLMove
.a1d8	a2 00		ldx #$00			ldx 	#0 							; print out.
.a1da					_CLIDisplay:
.a1da	bd 55 0a	lda $0a55,x			lda 	ErrorBuffer,x
.a1dd	20 30 a1	jsr $a130			jsr 	XPrint
.a1e0	e8		inx				inx
.a1e1	bd 55 0a	lda $0a55,x			lda 	ErrorBuffer,x
.a1e4	d0 f4		bne $a1da			bne 	_CLIDisplay
.a1e6	9c 55 0a	stz $0a55			stz 	ErrorBuffer 				; erase message
.a1e9	a9 03		lda #$03			lda 	#3 							; 3rd line
.a1eb	20 62 a2	jsr $a262			jsr 	CLMove
.a1ee	a9 07		lda #$07			lda 	#7
.a1f0	8d 85 0a	sta $0a85			sta 	SCColour
.a1f3	9c 2d 0a	stz $0a2d			stz 	InputBuffer
.a1f6					_CLIInput:
.a1f6	da		phx				phx 								; save pos
.a1f7	20 22 a1	jsr $a122			jsr 	XGetCursor 					; save screen pos
.a1fa	a9 a0		lda #$a0			lda 	#$A0 						; print reverse space
.a1fc	20 30 a1	jsr $a130			jsr 	XPrint
.a1ff	20 c2 a0	jsr $a0c2			jsr 	XGetKey 					; get keystroke
.a202	20 29 a1	jsr $a129			jsr 	XSetCursor 					; restore screen pos
.a205	fa		plx				plx
.a206	c9 0d		cmp #$0d			cmp 	#$0D 						; return execute
.a208	f0 1f		beq $a229			beq 	_CLIExecute
.a20a	c9 20		cmp #$20			cmp 	#' ' 						; space execute
.a20c	f0 1b		beq $a229			beq 	_CLIExecute
.a20e	90 28		bcc $a238			bcc		_CLICommandLine	 			; other controls clear
.a210	ec 81 0a	cpx $0a81			cpx 	SCWidth 					; off RHS
.a213	b0 e1		bcs $a1f6			bcs 	_CLIInput
.a215	e0 27		cpx #$27			cpx 	#BUFFERSIZE-1 				; won't fit
.a217	b0 dd		bcs $a1f6			bcs 	_CLIInput
.a219	29 3f		and #$3f			and 	#63 						; 6 bit ASCII
.a21b	20 30 a1	jsr $a130			jsr 	XPrint 						; print
.a21e	09 c0		ora #$c0			ora 	#COL_EXEC 					; make executable word
.a220	9d 2d 0a	sta $0a2d,x			sta 	InputBuffer,x 				; store
.a223	9e 2e 0a	stz $0a2e,x			stz 	InputBuffer+1,x
.a226	e8		inx				inx
.a227	80 cd		bra $a1f6			bra 	_CLIInput
.a229					_CLIExecute
.a229	a2 2d		ldx #$2d			ldx 	#InputBuffer & $FF 			; execute the buffer.
.a22b	a0 0a		ldy #$0a			ldy 	#InputBuffer >> 8
.a22d	20 a7 a2	jsr $a2a7			jsr 	BufferProcess
.a230	ad 7f 0a	lda $0a7f			lda 	CurrentIndex 				; check stack underflow
.a233	1a		inc a				inc 	a
.a234	c9 f8		cmp #$f8			cmp 	#248
.a236	b0 03		bcs $a23b			bcs 	_CLIUnderflow
.a238					_CLICommandLine:
.a238	4c 74 a1	jmp $a174			jmp 	CommandLine
.a23b					_CLIUnderflow:
.a23b	a9 ff		lda #$ff			lda 	#$FF 						; clear stack.
.a23d	8d 7f 0a	sta $0a7f			sta 	CurrentIndex
.a240	20 4d a2	jsr $a24d	_		jsr 	ReportError
>a243	55 4e 44 45 52 46 4c 4f				.text "UNDERFLOW",0
>a24b	57 00
.a24d					ReportError:
.a24d	fa		plx				plx
.a24e	7a		ply				ply
.a24f	84 11		sty $11				sty 	zTemp0+1
.a251	86 10		stx $10				stx 	zTemp0
.a253	a0 00		ldy #$00			ldy 	#0
.a255					_CopyError:
.a255	b1 10		lda ($10),y			lda 	(zTemp0),y
.a257	99 54 0a	sta $0a54,y			sta 	ErrorBuffer-1,y
.a25a	c8		iny				iny
.a25b	c9 00		cmp #$00			cmp 	#0
.a25d	d0 f6		bne $a255			bne 	_CopyError
.a25f	4c 74 a1	jmp $a174			jmp 	CommandLine
.a262	49 ff		eor #$ff	CLMove:	eor 	#$FF
.a264	38		sec				sec
.a265	6d 82 0a	adc $0a82			adc		SCHeight
.a268	a8		tay				tay
.a269	a2 00		ldx #$00			ldx 	#0
.a26b	4c 29 a1	jmp $a129			jmp 	XSetCursor
.a26e	48		pha		CLPrint:pha
.a26f	da		phx				phx
.a270	5a		phy				phy
.a271	20 22 a1	jsr $a122			jsr 	XGetCursor
.a274	8a		txa				txa
.a275	18		clc				clc
.a276	69 06		adc #$06			adc 	#6
.a278	cd 81 0a	cmp $0a81			cmp 	SCWidth
.a27b	b0 26		bcs $a2a3			bcs 	_CLNoPrint
.a27d	7a		ply				ply
.a27e	fa		plx				plx
.a27f	98		tya				tya
.a280	20 8c a2	jsr $a28c			jsr 	_CLByte
.a283	68		pla				pla
.a284	20 8c a2	jsr $a28c			jsr 	_CLByte
.a287	a9 20		lda #$20			lda 	#" "
.a289	4c 30 a1	jmp $a130			jmp 	XPrint
.a28c	48		pha		_CLByte:pha
.a28d	4a		lsr a				lsr	 	a
.a28e	4a		lsr a				lsr	 	a
.a28f	4a		lsr a				lsr	 	a
.a290	4a		lsr a				lsr	 	a
.a291	20 95 a2	jsr $a295			jsr 	_CLNibble
.a294	68		pla				pla
.a295					_CLNibble:
.a295	29 0f		and #$0f			and 	#15
.a297	18		clc				clc
.a298	69 30		adc #$30			adc 	#'0'
.a29a	c9 3a		cmp #$3a			cmp 	#58
.a29c	90 02		bcc $a2a0			bcc 	_CLPX
.a29e	69 06		adc #$06			adc 	#6
.a2a0	4c 30 a1	jmp $a130	_CLPX:	jmp		XPrint
.a2a3					_CLNoPrint:
.a2a3	7a		ply				ply
.a2a4	fa		plx				plx
.a2a5	68		pla				pla
.a2a6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: compiler/buffer.asm

.a2a7					BufferProcess:
.a2a7	84 1c		sty $1c				sty 	bufferPtr+1 				; save buffer pointer
.a2a9	86 1b		stx $1b				stx 	bufferPtr
.a2ab					_BPNextWord:
.a2ab	b2 1b		lda ($1b)			lda 	(bufferPtr) 				; check the next byte
.a2ad	f0 0e		beq $a2bd			beq 	_BPExit
.a2af	29 3f		and #$3f			and 	#$3F						; is it a space ?
.a2b1	c9 20		cmp #$20			cmp 	#' '
.a2b3	d0 09		bne $a2be			bne 	_BPFound 					; no, found a word.
.a2b5	e6 1b		inc $1b				inc 	bufferPtr 					; bump pointer over space
.a2b7	d0 f2		bne $a2ab			bne 	_BPNextWord
.a2b9	e6 1c		inc $1c				inc 	bufferPtr+1
.a2bb	80 ee		bra $a2ab			bra 	_BPNextWord
.a2bd					_BPExit:
.a2bd	60		rts				rts
.a2be					_BPFound:
.a2be	b2 1b		lda ($1b)			lda 	(bufferPtr) 				; start by getting the type bits off first character
.a2c0	29 c0		and #$c0			and 	#$C0						; bits 6 & 7
.a2c2	8d 04 0a	sta $0a04			sta 	wordType
.a2c5	a0 00		ldy #$00			ldy 	#0 							; copy the word.
.a2c7					_BPCopy:
.a2c7	b1 1b		lda ($1b),y			lda 	(bufferPtr),y 				; copy byte over, dropping the type bits
.a2c9	29 3f		and #$3f			and 	#$3F
.a2cb	99 05 0a	sta $0a05,y			sta 	SearchBuffer,y
.a2ce	c8		iny				iny
.a2cf	c0 40		cpy #$40			cpy 	#64 						; too long a word ?
.a2d1	f0 0a		beq $a2dd			beq 	_BPFoundEnd
.a2d3	b1 1b		lda ($1b),y			lda 	(bufferPtr),y 				; get next
.a2d5	f0 06		beq $a2dd			beq 	_BPFoundEnd 				; if zero, then it's the end of the word
.a2d7	29 3f		and #$3f			and 	#$3F 						; if not space, keep going.
.a2d9	c9 20		cmp #$20			cmp 	#' '
.a2db	d0 ea		bne $a2c7			bne 	_BPCopy
.a2dd					_BPFoundEnd:
.a2dd	b9 04 0a	lda $0a04,y			lda 	SearchBuffer-1,y 			; set bit 7 of the last character
.a2e0	09 80		ora #$80			ora 	#$80
.a2e2	99 04 0a	sta $0a04,y			sta 	SearchBuffer-1,y
.a2e5	98		tya				tya 								; add offset to space/zero to buffer pointer
.a2e6	18		clc				clc
.a2e7	65 1b		adc $1b				adc 	bufferPtr
.a2e9	85 1b		sta $1b				sta 	bufferPtr
.a2eb	90 02		bcc $a2ef			bcc 	_BPNoCarry
.a2ed	e6 1c		inc $1c				inc 	bufferPtr+1
.a2ef					_BPNoCarry:
.a2ef	ad 04 0a	lda $0a04			lda 	wordType 					; look at type
.a2f2	c9 00		cmp #$00			cmp 	#COL_COMMENT 			 	; comment (white), just go round again
.a2f4	f0 b5		beq $a2ab			beq 	_BPNextWord
.a2f6	c9 40		cmp #$40			cmp 	#COL_DEFINE					; word definition (red)
.a2f8	f0 09		beq $a303			beq 	_BPDefineWord
.a2fa	c9 c0		cmp #$c0			cmp 	#COL_EXEC 					; execute word immediately (yellow)
.a2fc	f0 0a		beq $a308			beq 	_BPExecute
.a2fe	20 91 a3	jsr $a391			jsr 	BPCompile 					; must be compile (green)
.a301	80 a8		bra $a2ab			bra 	_BPNextWord
.a303					_BPDefineWord:
.a303	20 0d a3	jsr $a30d			jsr 	BPDefineWord
.a306	80 a3		bra $a2ab			bra 	_BPNextWord
.a308					_BPExecute:
.a308	20 27 a3	jsr $a327			jsr 	BPExecute
.a30b	80 9e		bra $a2ab			bra 	_BPNextWord

;******  Return to file: main.asm


;******  Processing file: compiler/define.asm

.a30d					BPDefineWord:
.a30d	20 13 a4	jsr $a413			jsr 	UtilSearchAll 				; does it already exist
.a310	b0 04		bcs $a316			bcs 	_BPDWDuplicate
.a312	20 0b a0	jsr $a00b			jsr 	DictionaryCreate 			; create new word in the dictionary.
.a315	60		rts				rts
.a316					_BPDWDuplicate:
.a316	20 4d a2	jsr $a24d	_		jsr 	ReportError
>a319	44 55 50 4c 49 43 41 54				.text "DUPLICATE DEF",0
>a321	45 20 44 45 46 00

;******  Return to file: main.asm


;******  Processing file: compiler/execute.asm

.a327					BPExecute:
.a327	20 13 a4	jsr $a413			jsr 	UtilSearchAll 				; look for it in dictionaries
.a32a	b0 18		bcs $a344			bcs 	_BPEXFound 					; word found.
.a32c	20 2c a4	jsr $a42c			jsr 	UtilConvertInteger 			; Try as integer
.a32f	b0 41		bcs $a372			bcs 	_BPEXInteger 				; if integer, push on stack, otherwise error
.a331	20 4d a2	jsr $a24d	_		jsr 	ReportError
>a334	55 4e 4b 4e 4f 57 4e 20				.text "UNKNOWN EXECUTE",0
>a33c	45 58 45 43 55 54 45 00
.a344					_BPEXFound:
.a344	2c 03 0a	bit $0a03			bit 	dictType					; check if compile only
.a347	30 16		bmi $a35f			bmi 	_BPEXCompileOnly
.a349	ae 7f 0a	ldx $0a7f			ldx 	CurrentIndex 				; load the index, and TOS into X and YA
.a34c	ad 7d 0a	lda $0a7d			lda 	CurrentTOS
.a34f	ac 7e 0a	ldy $0a7e			ldy 	CurrentTOS+1
.a352	20 6f a3	jsr $a36f			jsr 	_BPEXWord 					; call the word code (set by dictionary search)
.a355	8e 7f 0a	stx $0a7f			stx 	CurrentIndex 				; save that state in 'current' variables
.a358	8d 7d 0a	sta $0a7d			sta 	CurrentTOS 					; which is X (stack) and YA (top of stack)
.a35b	8c 7e 0a	sty $0a7e			sty 	CurrentTOS+1
.a35e	60		rts				rts
.a35f					_BPEXCompileOnly:
.a35f	20 4d a2	jsr $a24d	_		jsr 	ReportError
>a362	43 4f 4d 50 49 4c 45 20				.text "COMPILE ONLY",0
>a36a	4f 4e 4c 59 00
.a36f					_BPEXWord:
.a36f	6c 00 0a	jmp ($0a00)			jmp 	(dictAddr)
.a372					_BPEXInteger:
.a372	48		pha				pha 								; save constant
.a373	5a		phy				phy
.a374	ae 7f 0a	ldx $0a7f			ldx 	CurrentIndex 				; load the index, and TOS into X and YA
.a377	ad 7d 0a	lda $0a7d			lda 	CurrentTOS
.a37a	ac 7e 0a	ldy $0a7e			ldy 	CurrentTOS+1
.a37d	e8		inx				inx 								; X points to TOS always
.a37e	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a381	98		tya				tya
.a382	9d 20 08	sta $0820,x			sta 	hStack,x
.a385	7a		ply				ply 								; restore constant
.a386	68		pla				pla
.a387	8e 7f 0a	stx $0a7f			stx 	CurrentIndex 				; save that state in 'current' variables
.a38a	8d 7d 0a	sta $0a7d			sta 	CurrentTOS 					; which is X (stack) and YA (top of stack)
.a38d	8c 7e 0a	sty $0a7e			sty 	CurrentTOS+1
.a390	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: compiler/compile.asm

.a391					BPCompile:
.a391	20 13 a4	jsr $a413			jsr 	UtilSearchAll 				; look for it in dictionaries
.a394	b0 1f		bcs $a3b5			bcs 	_BPCOFound 					; word found.
.a396	20 2c a4	jsr $a42c			jsr 	UtilConvertInteger 			; is it a number
.a399	b0 1e		bcs $a3b9			bcs 	_BPCONumber 				; if so, do a number.
.a39b	ad 05 0a	lda $0a05			lda 	SearchBuffer 				; is it a quoted string ?
.a39e	c9 22		cmp #$22			cmp 	#'"'
.a3a0	f0 41		beq $a3e3			beq 	_BPCOString
.a3a2	20 4d a2	jsr $a24d	_		jsr 	ReportError
>a3a5	55 4e 4b 4e 4f 57 4e 20				.text "UNKNOWN COMPILE",0
>a3ad	43 4f 4d 50 49 4c 45 00
.a3b5					_BPCOFound:
.a3b5	20 8a a4	jsr $a48a			jsr 	UtilCompileCall 			; compile call to currently found element
.a3b8	60		rts				rts
.a3b9					_BPCONumber:
.a3b9	c0 00		cpy #$00			cpy 	#0 							; check if 8 bit constant
.a3bb	f0 14		beq $a3d1			beq 	_BPCOShort
.a3bd	48		pha				pha 								; 16 bit constant
.a3be	5a		phy				phy
.a3bf	a9 20		lda #$20			lda 	#$20 						; compile call
.a3c1	20 a9 a4	jsr $a4a9			jsr 	UtilCompileByte
.a3c4	a9 b2		lda #$b2			lda 	#Constant_2Byte & $FF
.a3c6	a0 a4		ldy #$a4			ldy 	#Constant_2Byte >> 8
.a3c8	20 9d a4	jsr $a49d			jsr 	UtilCompileWord
.a3cb	7a		ply				ply
.a3cc	68		pla				pla
.a3cd	20 9d a4	jsr $a49d			jsr 	UtilCompileWord 			; compile the actual word
.a3d0	60		rts				rts
.a3d1					_BPCOShort:
.a3d1	48		pha				pha
.a3d2	a9 20		lda #$20			lda 	#$20 						; compile call
.a3d4	20 a9 a4	jsr $a4a9			jsr 	UtilCompileByte
.a3d7	a9 d2		lda #$d2			lda 	#Constant_1Byte & $FF
.a3d9	a0 a4		ldy #$a4			ldy 	#Constant_1Byte >> 8
.a3db	20 9d a4	jsr $a49d			jsr 	UtilCompileWord
.a3de	68		pla				pla
.a3df	20 a9 a4	jsr $a4a9			jsr 	UtilCompileByte 			; compile the actual byte
.a3e2	60		rts				rts
.a3e3					_BPCOString:
.a3e3	a9 20		lda #$20			lda 	#$20 						; compile call
.a3e5	20 a9 a4	jsr $a4a9			jsr 	UtilCompileByte
.a3e8	a9 eb		lda #$eb			lda 	#Constant_String & $FF
.a3ea	a0 a4		ldy #$a4			ldy 	#Constant_String >> 8
.a3ec	20 9d a4	jsr $a49d			jsr 	UtilCompileWord
.a3ef	da		phx				phx 								; find length of string.
.a3f0	a2 00		ldx #$00			ldx 	#0
.a3f2					_BPCOSFindLength:
.a3f2	e8		inx				inx
.a3f3	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x
.a3f6	10 fa		bpl $a3f2			bpl 	_BPCOSFindLength
.a3f8	8a		txa				txa
.a3f9	20 a9 a4	jsr $a4a9			jsr 	UtilCompileByte
.a3fc	a2 01		ldx #$01			ldx 	#1 							; compile the string
.a3fe					_BPCOSCompile:
.a3fe	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x
.a401	c9 5f		cmp #$5f			cmp 	#"_" 						; map _ to space
.a403	d0 02		bne $a407			bne		_BPCOSNotSpace
.a405	a9 20		lda #$20			lda 	#" "
.a407					_BPCOSNotSpace:
.a407	20 a9 a4	jsr $a4a9			jsr 	UtilCompileByte
.a40a	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x
.a40d	0a		asl a				asl 	a
.a40e	e8		inx				inx
.a40f	90 ed		bcc $a3fe			bcc 	_BPCOSCompile
.a411	fa		plx				plx
.a412	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: compiler/utilities.asm

.a413					UtilSearchAll:
.a413	a9 00		lda #$00			lda 	#DictionaryBase & $FF		; search the user dictionary
.a415	a2 10		ldx #$10			ldx 	#DictionaryBase >> 8
.a417	85 10		sta $10				sta 	zTemp0
.a419	86 11		stx $11				stx 	zTemp0+1
.a41b	20 09 a0	jsr $a009			jsr 	DictionarySearch
.a41e	b0 0b		bcs $a42b			bcs 	_BSAExit
.a420	a9 cf		lda #$cf			lda 	#KernelDictionary & $FF		; search the system dictionary
.a422	a2 a7		ldx #$a7			ldx 	#KernelDictionary >> 8
.a424	85 10		sta $10				sta 	zTemp0
.a426	86 11		stx $11				stx 	zTemp0+1
.a428	20 09 a0	jsr $a009			jsr 	DictionarySearch
.a42b					_BSAExit:
.a42b	60		rts				rts
.a42c					UtilConvertInteger:
.a42c	64 10		stz $10				stz 	zTemp0 						; zero the result
.a42e	64 11		stz $11				stz 	zTemp0+1
.a430	a2 ff		ldx #$ff			ldx 	#255 						; start position-1
.a432					_BCILoop:
.a432	e8		inx				inx 								; next character
.a433	20 6f a4	jsr $a46f			jsr 	UtilTimes10 				; zTemp0 x 10
.a436	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x 				; look at character
.a439	29 7f		and #$7f			and 	#$7F  						; drop end character bit
.a43b	c9 30		cmp #$30			cmp 	#'0'						; is it an integer character
.a43d	90 2e		bcc $a46d			bcc 	_BCIFail 					; if not, then exit.
.a43f	c9 3a		cmp #$3a			cmp 	#'9'+1
.a441	b0 2a		bcs $a46d			bcs 	_BCIFail
.a443	29 0f		and #$0f			and 	#15 						; now constant 0-9
.a445	18		clc				clc 								; add to current
.a446	65 10		adc $10				adc 	zTemp0
.a448	85 10		sta $10				sta 	zTemp0
.a44a	90 02		bcc $a44e			bcc 	_BCINoCarry
.a44c	e6 11		inc $11				inc 	zTemp0+1
.a44e					_BCINoCarry:
.a44e	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x 				; check if was last character
.a451	30 14		bmi $a467			bmi 	_BCISucceed 				; if so, then it's okay.
.a453	bd 06 0a	lda $0a06,x			lda 	SearchBuffer+1,x 			; is the next char -+End
.a456	c9 ad		cmp #$ad			cmp 	#"-"+$80
.a458	d0 d8		bne $a432			bne 	_BCILoop 					; no, go round again.
.a45a					_BCINegateExit:
.a45a	38		sec				sec
.a45b	a9 00		lda #$00			lda 	#0 							; do the arithmetic adjustment
.a45d	e5 10		sbc $10				sbc 	zTemp0
.a45f	85 10		sta $10				sta 	zTemp0
.a461	a9 00		lda #$00			lda 	#0
.a463	e5 11		sbc $11				sbc 	zTemp0+1
.a465	85 11		sta $11				sta 	zTemp0+1
.a467					_BCISucceed:
.a467	38		sec				sec
.a468	a5 10		lda $10				lda 	zTemp0
.a46a	a4 11		ldy $11				ldy 	zTemp0+1
.a46c	60		rts				rts
.a46d					_BCIFail:
.a46d	18		clc				clc
.a46e	60		rts				rts
.a46f					UtilTimes10:
.a46f	a5 11		lda $11				lda 	zTemp0+1 					; save in YA
.a471	a8		tay				tay
.a472	a5 10		lda $10				lda 	zTemp0
.a474	06 10		asl $10				asl 	zTemp0 						; x 4
.a476	26 11		rol $11				rol 	zTemp0+1
.a478	06 10		asl $10				asl 	zTemp0
.a47a	26 11		rol $11				rol 	zTemp0+1
.a47c	65 10		adc $10				adc 	zTemp0 						; add YA value gives x 5
.a47e	85 10		sta $10				sta 	zTemp0
.a480	98		tya				tya
.a481	65 11		adc $11				adc 	zTemp0+1
.a483	85 11		sta $11				sta 	zTemp0+1
.a485	06 10		asl $10				asl 	zTemp0	 					; x 10
.a487	26 11		rol $11				rol 	zTemp0+1
.a489	60		rts				rts
.a48a					UtilCompileCall:
.a48a	48		pha				pha
.a48b	5a		phy				phy
.a48c	a9 20		lda #$20			lda 	#$20 						; JSR
.a48e	20 a9 a4	jsr $a4a9			jsr 	UtilCompileByte
.a491	ad 00 0a	lda $0a00			lda 	dictAddr
.a494	ac 01 0a	ldy $0a01			ldy 	dictAddr+1
.a497	20 9d a4	jsr $a49d			jsr 	UtilCompileWord
.a49a	7a		ply				ply
.a49b	68		pla				pla
.a49c	60		rts				rts
.a49d					UtilCompileWord:
.a49d	48		pha				pha
.a49e	5a		phy				phy
.a49f	20 a9 a4	jsr $a4a9			jsr 	UtilCompileByte
.a4a2	98		tya				tya
.a4a3	20 a9 a4	jsr $a4a9			jsr 	UtilCompileByte
.a4a6	7a		ply				ply
.a4a7	68		pla				pla
.a4a8	60		rts				rts
.a4a9					UtilCompileByte:
.a4a9	92 16		sta ($16)			sta 	(freeCode)
.a4ab	e6 16		inc $16				inc 	freeCode
.a4ad	d0 02		bne $a4b1			bne 	_UCBNoCarry
.a4af	e6 17		inc $17				inc 	freeCode+1
.a4b1					_UCBNoCarry:
.a4b1	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: compiler/support.asm

.a4b2					Constant_2Byte:
.a4b2	e8		inx				inx 								; X points to TOS always
.a4b3	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a4b6	98		tya				tya
.a4b7	9d 20 08	sta $0820,x			sta 	hStack,x
.a4ba	68		pla				pla 								; get return address into YA
.a4bb	7a		ply				ply
.a4bc	1a		inc a				inc 	a
.a4bd	d0 01		bne $a4c0			bne		*+3
.a4bf	c8		iny				iny
.a4c0	85 10		sta $10				sta 	zTemp0 						; save address in zero page
.a4c2	84 11		sty $11				sty 	zTemp0+1
.a4c4	1a		inc a				inc 	a
.a4c5	d0 01		bne $a4c8			bne		*+3
.a4c7	c8		iny				iny
.a4c8	5a		phy				phy 								; push it back
.a4c9	48		pha				pha
.a4ca	a0 01		ldy #$01			ldy 	#1 							; load the constant into YA
.a4cc	b1 10		lda ($10),y			lda 	(zTemp0),y
.a4ce	a8		tay				tay
.a4cf	b2 10		lda ($10)			lda 	(zTemp0)
.a4d1	60		rts				rts
.a4d2					Constant_1Byte:
.a4d2	e8		inx				inx 								; X points to TOS always
.a4d3	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a4d6	98		tya				tya
.a4d7	9d 20 08	sta $0820,x			sta 	hStack,x
.a4da	68		pla				pla 								; get return address into YA
.a4db	7a		ply				ply
.a4dc	1a		inc a				inc 	a
.a4dd	d0 01		bne $a4e0			bne		*+3
.a4df	c8		iny				iny
.a4e0	85 10		sta $10				sta 	zTemp0 						; save address in zero page
.a4e2	84 11		sty $11				sty 	zTemp0+1
.a4e4	5a		phy				phy 								; push it back
.a4e5	48		pha				pha
.a4e6	b2 10		lda ($10)			lda 	(zTemp0)
.a4e8	a0 00		ldy #$00			ldy 	#0
.a4ea	60		rts				rts
.a4eb					Constant_String:
.a4eb	e8		inx				inx 								; X points to TOS always
.a4ec	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a4ef	98		tya				tya
.a4f0	9d 20 08	sta $0820,x			sta 	hStack,x
.a4f3	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: vocabulary/system.voc

.a4f4					System_ResetStack:
.a4f4	a2 ff		ldx #$ff			ldx 	#-1 						; reset the stack pointer
.a4f6	a9 00		lda #$00			lda 	#0 							; clear the tos value held in YA
.a4f8	a8		tay				tay
.a4f9	60		rts				rts
.a4fa					System_ResetUserDictionary:
.a4fa	20 07 a0	jsr $a007			jsr 	DictionaryReset 			; reset the dictionary and code pointer.
.a4fd	60		rts				rts
.a4fe					System_ColdStart:
.a4fe	4c a6 a0	jmp $a0a6			jmp 	ColdStart
.a501					System_Break:
>a501	ff						.byte 	$FF
.a502	60		rts				rts
.a503					System_CompileByte:
.a503	20 a9 a4	jsr $a4a9			jsr 	UtilCompileByte
.a506	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a509	a8		tay				tay
.a50a	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a50d	ca		dex				dex 								; fix up stack
.a50e	60		rts				rts
.a50f					System_CompileWord:
.a50f	20 9d a4	jsr $a49d			jsr 	UtilCompileWord
.a512	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a515	a8		tay				tay
.a516	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a519	ca		dex				dex 								; fix up stack
.a51a	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/constants.voc

.a51b					Constant_0:
.a51b	e8		inx				inx 								; X points to TOS always
.a51c	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a51f	98		tya				tya
.a520	9d 20 08	sta $0820,x			sta 	hStack,x
.a523	a9 00		lda #$00			lda 	#(0) & $FF					; load new constant into YA
.a525	a0 00		ldy #$00			ldy 	#(0) >> 8
.a527	60		rts				rts
.a528					Constant_1:
.a528	e8		inx				inx 								; X points to TOS always
.a529	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a52c	98		tya				tya
.a52d	9d 20 08	sta $0820,x			sta 	hStack,x
.a530	a9 01		lda #$01			lda 	#(1) & $FF					; load new constant into YA
.a532	a0 00		ldy #$00			ldy 	#(1) >> 8
.a534	60		rts				rts
.a535					Constant_2:
.a535	e8		inx				inx 								; X points to TOS always
.a536	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a539	98		tya				tya
.a53a	9d 20 08	sta $0820,x			sta 	hStack,x
.a53d	a9 02		lda #$02			lda 	#(2) & $FF					; load new constant into YA
.a53f	a0 00		ldy #$00			ldy 	#(2) >> 8
.a541	60		rts				rts
.a542					Constant_4:
.a542	e8		inx				inx 								; X points to TOS always
.a543	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a546	98		tya				tya
.a547	9d 20 08	sta $0820,x			sta 	hStack,x
.a54a	a9 04		lda #$04			lda 	#(4) & $FF					; load new constant into YA
.a54c	a0 00		ldy #$00			ldy 	#(4) >> 8
.a54e	60		rts				rts
.a54f					Constant_6:
.a54f	e8		inx				inx 								; X points to TOS always
.a550	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a553	98		tya				tya
.a554	9d 20 08	sta $0820,x			sta 	hStack,x
.a557	a9 06		lda #$06			lda 	#(6) & $FF					; load new constant into YA
.a559	a0 00		ldy #$00			ldy 	#(6) >> 8
.a55b	60		rts				rts
.a55c					Constant_8:
.a55c	e8		inx				inx 								; X points to TOS always
.a55d	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a560	98		tya				tya
.a561	9d 20 08	sta $0820,x			sta 	hStack,x
.a564	a9 08		lda #$08			lda 	#(8) & $FF					; load new constant into YA
.a566	a0 00		ldy #$00			ldy 	#(8) >> 8
.a568	60		rts				rts
.a569					Constant_10:
.a569	e8		inx				inx 								; X points to TOS always
.a56a	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a56d	98		tya				tya
.a56e	9d 20 08	sta $0820,x			sta 	hStack,x
.a571	a9 0a		lda #$0a			lda 	#(10) & $FF					; load new constant into YA
.a573	a0 00		ldy #$00			ldy 	#(10) >> 8
.a575	60		rts				rts
.a576					Constant_12:
.a576	e8		inx				inx 								; X points to TOS always
.a577	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a57a	98		tya				tya
.a57b	9d 20 08	sta $0820,x			sta 	hStack,x
.a57e	a9 0c		lda #$0c			lda 	#(12) & $FF					; load new constant into YA
.a580	a0 00		ldy #$00			ldy 	#(12) >> 8
.a582	60		rts				rts
.a583					Constant_14:
.a583	e8		inx				inx 								; X points to TOS always
.a584	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a587	98		tya				tya
.a588	9d 20 08	sta $0820,x			sta 	hStack,x
.a58b	a9 0e		lda #$0e			lda 	#(14) & $FF					; load new constant into YA
.a58d	a0 00		ldy #$00			ldy 	#(14) >> 8
.a58f	60		rts				rts
.a590					Constant_16:
.a590	e8		inx				inx 								; X points to TOS always
.a591	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a594	98		tya				tya
.a595	9d 20 08	sta $0820,x			sta 	hStack,x
.a598	a9 10		lda #$10			lda 	#(16) & $FF					; load new constant into YA
.a59a	a0 00		ldy #$00			ldy 	#(16) >> 8
.a59c	60		rts				rts
.a59d					Constant_24:
.a59d	e8		inx				inx 								; X points to TOS always
.a59e	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a5a1	98		tya				tya
.a5a2	9d 20 08	sta $0820,x			sta 	hStack,x
.a5a5	a9 18		lda #$18			lda 	#(24) & $FF					; load new constant into YA
.a5a7	a0 00		ldy #$00			ldy 	#(24) >> 8
.a5a9	60		rts				rts
.a5aa					Constant_32:
.a5aa	e8		inx				inx 								; X points to TOS always
.a5ab	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a5ae	98		tya				tya
.a5af	9d 20 08	sta $0820,x			sta 	hStack,x
.a5b2	a9 20		lda #$20			lda 	#(32) & $FF					; load new constant into YA
.a5b4	a0 00		ldy #$00			ldy 	#(32) >> 8
.a5b6	60		rts				rts
.a5b7					Constant_64:
.a5b7	e8		inx				inx 								; X points to TOS always
.a5b8	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a5bb	98		tya				tya
.a5bc	9d 20 08	sta $0820,x			sta 	hStack,x
.a5bf	a9 40		lda #$40			lda 	#(64) & $FF					; load new constant into YA
.a5c1	a0 00		ldy #$00			ldy 	#(64) >> 8
.a5c3	60		rts				rts
.a5c4					Constant_100:
.a5c4	e8		inx				inx 								; X points to TOS always
.a5c5	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a5c8	98		tya				tya
.a5c9	9d 20 08	sta $0820,x			sta 	hStack,x
.a5cc	a9 64		lda #$64			lda 	#(100) & $FF					; load new constant into YA
.a5ce	a0 00		ldy #$00			ldy 	#(100) >> 8
.a5d0	60		rts				rts
.a5d1					Constant_127:
.a5d1	e8		inx				inx 								; X points to TOS always
.a5d2	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a5d5	98		tya				tya
.a5d6	9d 20 08	sta $0820,x			sta 	hStack,x
.a5d9	a9 7f		lda #$7f			lda 	#(127) & $FF					; load new constant into YA
.a5db	a0 00		ldy #$00			ldy 	#(127) >> 8
.a5dd	60		rts				rts
.a5de					Constant_128:
.a5de	e8		inx				inx 								; X points to TOS always
.a5df	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a5e2	98		tya				tya
.a5e3	9d 20 08	sta $0820,x			sta 	hStack,x
.a5e6	a9 80		lda #$80			lda 	#(128) & $FF					; load new constant into YA
.a5e8	a0 00		ldy #$00			ldy 	#(128) >> 8
.a5ea	60		rts				rts
.a5eb					Constant_255:
.a5eb	e8		inx				inx 								; X points to TOS always
.a5ec	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a5ef	98		tya				tya
.a5f0	9d 20 08	sta $0820,x			sta 	hStack,x
.a5f3	a9 ff		lda #$ff			lda 	#(255) & $FF					; load new constant into YA
.a5f5	a0 00		ldy #$00			ldy 	#(255) >> 8
.a5f7	60		rts				rts
.a5f8					Constant_256:
.a5f8	e8		inx				inx 								; X points to TOS always
.a5f9	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a5fc	98		tya				tya
.a5fd	9d 20 08	sta $0820,x			sta 	hStack,x
.a600	a9 00		lda #$00			lda 	#(256) & $FF					; load new constant into YA
.a602	a0 01		ldy #$01			ldy 	#(256) >> 8
.a604	60		rts				rts
.a605					Constant_512:
.a605	e8		inx				inx 								; X points to TOS always
.a606	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a609	98		tya				tya
.a60a	9d 20 08	sta $0820,x			sta 	hStack,x
.a60d	a9 00		lda #$00			lda 	#(512) & $FF					; load new constant into YA
.a60f	a0 02		ldy #$02			ldy 	#(512) >> 8
.a611	60		rts				rts
.a612					Constant_1024:
.a612	e8		inx				inx 								; X points to TOS always
.a613	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a616	98		tya				tya
.a617	9d 20 08	sta $0820,x			sta 	hStack,x
.a61a	a9 00		lda #$00			lda 	#(1024) & $FF					; load new constant into YA
.a61c	a0 04		ldy #$04			ldy 	#(1024) >> 8
.a61e	60		rts				rts
.a61f					Constant_2048:
.a61f	e8		inx				inx 								; X points to TOS always
.a620	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a623	98		tya				tya
.a624	9d 20 08	sta $0820,x			sta 	hStack,x
.a627	a9 00		lda #$00			lda 	#(2048) & $FF					; load new constant into YA
.a629	a0 08		ldy #$08			ldy 	#(2048) >> 8
.a62b	60		rts				rts
.a62c					Constant_4096:
.a62c	e8		inx				inx 								; X points to TOS always
.a62d	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a630	98		tya				tya
.a631	9d 20 08	sta $0820,x			sta 	hStack,x
.a634	a9 00		lda #$00			lda 	#(4096) & $FF					; load new constant into YA
.a636	a0 10		ldy #$10			ldy 	#(4096) >> 8
.a638	60		rts				rts
.a639					Constant_32767:
.a639	e8		inx				inx 								; X points to TOS always
.a63a	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a63d	98		tya				tya
.a63e	9d 20 08	sta $0820,x			sta 	hStack,x
.a641	a9 ff		lda #$ff			lda 	#(32767) & $FF					; load new constant into YA
.a643	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.a645	60		rts				rts
.a646					Constant_32768:
.a646	e8		inx				inx 								; X points to TOS always
.a647	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a64a	98		tya				tya
.a64b	9d 20 08	sta $0820,x			sta 	hStack,x
.a64e	a9 00		lda #$00			lda 	#(32768) & $FF					; load new constant into YA
.a650	a0 80		ldy #$80			ldy 	#(32768) >> 8
.a652	60		rts				rts
.a653					Constant_minus1:
.a653	e8		inx				inx 								; X points to TOS always
.a654	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a657	98		tya				tya
.a658	9d 20 08	sta $0820,x			sta 	hStack,x
.a65b	a9 ff		lda #$ff			lda 	#(65535) & $FF					; load new constant into YA
.a65d	a0 ff		ldy #$ff			ldy 	#(65535) >> 8
.a65f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: vocabulary/unary.voc

.a660					Unary_BSwap:
.a660	48		pha				pha 								; save A
.a661	98		tya				tya 								; Y->A
.a662	7a		ply				ply 								; old A->Y
.a663	60		rts				rts
.a664					Unary_Not:
.a664	49 ff		eor #$ff			eor 	#$FF
.a666	48		pha				pha
.a667	98		tya				tya
.a668	49 ff		eor #$ff			eor 	#$FF
.a66a	a8		tay				tay
.a66b	68		pla				pla
.a66c	60		rts				rts
.a66d					Unary_Abs:
.a66d	c0 00		cpy #$00			cpy 	#0 							; do -ve code if -ve
.a66f	30 01		bmi $a672			bmi 	Unary_Negate
.a671	60		rts				rts
.a672					Unary_Negate:
.a672	49 ff		eor #$ff			eor 	#$FF
.a674	48		pha				pha
.a675	98		tya				tya
.a676	49 ff		eor #$ff			eor 	#$FF
.a678	a8		tay				tay
.a679	68		pla				pla
.a67a	1a		inc a				inc 	a
.a67b	d0 01		bne $a67e			bne		*+3
.a67d	c8		iny				iny
.a67e	60		rts				rts
.a67f					Unary_Times16:
.a67f	0a		asl a				asl 	a 							; shift low left
.a680	48		pha				pha
.a681	98		tya				tya 								; shift high left
.a682	2a		rol a				rol 	a
.a683	a8		tay				tay
.a684	68		pla				pla
.a685					Unary_Times8:
.a685	0a		asl a				asl 	a 							; shift low left
.a686	48		pha				pha
.a687	98		tya				tya 								; shift high left
.a688	2a		rol a				rol 	a
.a689	a8		tay				tay
.a68a	68		pla				pla
.a68b					Unary_Times4:
.a68b	0a		asl a				asl 	a 							; shift low left
.a68c	48		pha				pha
.a68d	98		tya				tya 								; shift high left
.a68e	2a		rol a				rol 	a
.a68f	a8		tay				tay
.a690	68		pla				pla
.a691					Unary_Times2:
.a691	0a		asl a				asl 	a 							; shift low left
.a692	48		pha				pha
.a693	98		tya				tya 								; shift high left
.a694	2a		rol a				rol 	a
.a695	a8		tay				tay
.a696	68		pla				pla
.a697	60		rts				rts
.a698					Unary_Div4:
.a698	48		pha				pha 								; save low
.a699	98		tya				tya 								; get high, shift MSB into C
.a69a	0a		asl a				asl 	a
.a69b	98		tya				tya 								; get high again, rotate C in
.a69c	6a		ror a				ror 	a
.a69d	a8		tay				tay
.a69e	68		pla				pla 								; restore low and rotate right
.a69f	6a		ror a				ror 	a
.a6a0					Unary_Div2:
.a6a0	48		pha				pha 								; save low
.a6a1	98		tya				tya 								; get high, shift MSB into C
.a6a2	0a		asl a				asl 	a
.a6a3	98		tya				tya 								; get high again, rotate C in
.a6a4	6a		ror a				ror 	a
.a6a5	a8		tay				tay
.a6a6	68		pla				pla 								; restore low and rotate right
.a6a7	6a		ror a				ror 	a
.a6a8	60		rts				rts
.a6a9					Unary_Inc2:
.a6a9	1a		inc a				inc 	a
.a6aa	d0 01		bne $a6ad			bne		*+3
.a6ac	c8		iny				iny
.a6ad					Unary_Inc1:
.a6ad	1a		inc a				inc 	a
.a6ae	d0 01		bne $a6b1			bne		*+3
.a6b0	c8		iny				iny
.a6b1	60		rts				rts
.a6b2					Unary_Dec2:
.a6b2	38		sec				sec
.a6b3	e9 02		sbc #$02			sbc 	#2
.a6b5	b0 01		bcs $a6b8			bcs		*+3
.a6b7	88		dey				dey
.a6b8	60		rts				rts
.a6b9					UnaryDec1:
.a6b9	38		sec				sec
.a6ba	e9 01		sbc #$01			sbc 	#1
.a6bc	b0 01		bcs $a6bf			bcs		*+3
.a6be	88		dey				dey
.a6bf	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: vocabulary/binary.voc

.a6c0					Binary_Add:
.a6c0	18		clc				clc
.a6c1	7d 00 08	adc $0800,x			adc 	lStack,x 					; do the LSB
.a6c4	48		pha				pha 								; save the result
.a6c5	98		tya				tya 								; do the MSB
.a6c6	7d 20 08	adc $0820,x			adc 	hStack,x
.a6c9	a8		tay				tay
.a6ca	68		pla				pla 								; restore
.a6cb	ca		dex				dex 								; pop off the stack.
.a6cc	60		rts				rts
.a6cd					Binary_And:
.a6cd	3d 00 08	and $0800,x			and 	lStack,x 					; do the LSB
.a6d0	48		pha				pha 								; save the result
.a6d1	98		tya				tya 								; do the MSB
.a6d2	3d 20 08	and $0820,x			and 	hStack,x
.a6d5	a8		tay				tay
.a6d6	68		pla				pla 								; restore
.a6d7	ca		dex				dex 								; pop off the stack.
.a6d8	60		rts				rts
.a6d9					Binary_Or:
.a6d9	1d 00 08	ora $0800,x			ora 	lStack,x 					; do the LSB
.a6dc	48		pha				pha 								; save the result
.a6dd	98		tya				tya 								; do the MSB
.a6de	1d 20 08	ora $0820,x			ora 	hStack,x
.a6e1	a8		tay				tay
.a6e2	68		pla				pla 								; restore
.a6e3	ca		dex				dex 								; pop off the stack.
.a6e4	60		rts				rts
.a6e5					Binary_Xor:
.a6e5	5d 00 08	eor $0800,x			eor 	lStack,x 					; do the LSB
.a6e8	48		pha				pha 								; save the result
.a6e9	98		tya				tya 								; do the MSB
.a6ea	5d 20 08	eor $0820,x			eor 	hStack,x
.a6ed	a8		tay				tay
.a6ee	68		pla				pla 								; restore
.a6ef	ca		dex				dex 								; pop off the stack.
.a6f0	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: vocabulary/stack.voc

.a6f1					Stack_Drop:
.a6f1	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a6f4	a8		tay				tay
.a6f5	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a6f8	ca		dex				dex 								; fix up stack
.a6f9	60		rts				rts
.a6fa					Stack_QDup:
.a6fa	c9 00		cmp #$00			cmp 	#0
.a6fc	d0 05		bne $a703			bne 	Stack_Dup
.a6fe	c0 00		cpy #$00			cpy 	#0
.a700	d0 01		bne $a703			bne 	Stack_Dup
.a702	60		rts				rts
.a703					Stack_Dup:
.a703	48		pha				pha
.a704	e8		inx				inx 								; X points to TOS always
.a705	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a708	98		tya				tya
.a709	9d 20 08	sta $0820,x			sta 	hStack,x
.a70c	68		pla				pla
.a70d	60		rts				rts
.a70e					Stack_Nip:
.a70e	ca		dex				dex
.a70f	60		rts				rts
.a710					Stack_Over:
.a710	e8		inx				inx 								; X points to TOS always
.a711	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a714	98		tya				tya
.a715	9d 20 08	sta $0820,x			sta 	hStack,x
.a718	bd 1f 08	lda $081f,x			lda 	hStack-1,x 					; copy 2nd element to YA
.a71b	a8		tay				tay
.a71c	bd ff 07	lda $07ff,x			lda 	lStack-1,x
.a71f	60		rts				rts
.a720					Stack_Swap:
.a720	85 10		sta $10				sta 	zTemp0 						; save A
.a722	84 11		sty $11				sty 	zTemp0+1 					; save Y
.a724	bd 00 08	lda $0800,x			lda 	lStack,x 					; push 2nd A on stack
.a727	48		pha				pha
.a728	bd 20 08	lda $0820,x			lda 	hStack,x 					; get 2nd Y
.a72b	a8		tay				tay
.a72c	a5 10		lda $10				lda 	zTemp0 						; first A
.a72e	9d 00 08	sta $0800,x			sta 	lStack,x
.a731	a5 11		lda $11				lda 	zTemp0+1					; first Y
.a733	9d 20 08	sta $0820,x			sta 	hStack,x
.a736	68		pla				pla 								; restore 2nd A
.a737	60		rts				rts
.a738					Stack_Push:
.a738	85 10		sta $10				sta 	zTemp0 						; save TOS
.a73a	84 11		sty $11				sty 	zTemp0+1
.a73c	86 12		stx $12				stx 	zTemp1 						; save X
.a73e	fa		plx				plx 								; return address into YX
.a73f	7a		ply				ply
.a740	a5 10		lda $10				lda 	zTemp0						; push LSB
.a742	48		pha				pha
.a743	a5 11		lda $11				lda 	zTemp0+1 					; push MSB
.a745	48		pha				pha
.a746	5a		phy				phy 								; save address back.
.a747	da		phx				phx
.a748	a6 12		ldx $12				ldx 	zTemp1 						; restore X
.a74a	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a74d	a8		tay				tay
.a74e	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a751	ca		dex				dex 								; fix up stack
.a752	60		rts				rts
.a753					Stack_Pull:
.a753	e8		inx				inx 								; X points to TOS always
.a754	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a757	98		tya				tya
.a758	9d 20 08	sta $0820,x			sta 	hStack,x
.a75b	68		pla				pla 								; get return address
.a75c	85 10		sta $10				sta 	zTemp0
.a75e	7a		ply				ply
.a75f	68		pla				pla 								; get MSB
.a760	85 13		sta $13				sta 	zTemp1+1
.a762	68		pla				pla  								; get LSB
.a763	85 12		sta $12				sta 	zTemp1
.a765	5a		phy				phy 								; restore return address.
.a766	a5 10		lda $10				lda 	zTemp0
.a768	48		pha				pha
.a769	a5 12		lda $12				lda 	zTemp1 						; set up YA
.a76b	a4 13		ldy $13				ldy 	zTemp1+1
.a76d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: vocabulary/memory.voc

.a76e					Memory_ReadByte:
.a76e	85 10		sta $10				sta 	zTemp0 						; save address
.a770	84 11		sty $11				sty 	zTemp0+1
.a772	b2 10		lda ($10)			lda 	(zTemp0) 					; load byte in.
.a774	a0 00		ldy #$00			ldy 	#0
.a776	60		rts				rts
.a777					Memory_ReadWord:
.a777	85 10		sta $10				sta 	zTemp0 						; save address
.a779	84 11		sty $11				sty 	zTemp0+1
.a77b	a0 01		ldy #$01			ldy 	#1							; get high byte
.a77d	b1 10		lda ($10),y			lda 	(zTemp0),y
.a77f	a8		tay				tay
.a780	b2 10		lda ($10)			lda 	(zTemp0) 					; load low byte in.
.a782	60		rts				rts
.a783					Memory_WriteByte:
.a783	85 10		sta $10				sta 	zTemp0 						; save address
.a785	84 11		sty $11				sty 	zTemp0+1
.a787	bd 00 08	lda $0800,x			lda 	lStack,x 					; load byte in.
.a78a	92 10		sta ($10)			sta 	(zTemp0)					; write it.
.a78c	ca		dex				dex 								; throw one away
.a78d	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a790	a8		tay				tay
.a791	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a794	ca		dex				dex 								; fix up stack
.a795	60		rts				rts
.a796					Memory_WriteWord:
.a796	85 10		sta $10				sta 	zTemp0 						; save address
.a798	84 11		sty $11				sty 	zTemp0+1
.a79a	bd 20 08	lda $0820,x			lda 	hStack,x 					; load high byte in.
.a79d	a0 01		ldy #$01			ldy 	#1
.a79f	91 10		sta ($10),y			sta 	(zTemp0),y					; write it.
.a7a1	bd 00 08	lda $0800,x			lda 	lStack,x 					; load low byte in.
.a7a4	92 10		sta ($10)			sta 	(zTemp0)					; write it.
.a7a6	ca		dex				dex 								; throw one away
.a7a7	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a7aa	a8		tay				tay
.a7ab	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a7ae	ca		dex				dex 								; fix up stack
.a7af	60		rts				rts
.a7b0					Memory_AddWord:
.a7b0	85 10		sta $10				sta 	zTemp0 						; save address
.a7b2	84 11		sty $11				sty 	zTemp0+1
.a7b4	18		clc				clc
.a7b5	bd 00 08	lda $0800,x			lda 	lStack,x 					; load low byte in.
.a7b8	72 10		adc ($10)			adc 	(zTemp0)					; add it
.a7ba	92 10		sta ($10)			sta 	(zTemp0)					; write it.
.a7bc	a0 01		ldy #$01			ldy 	#1
.a7be	bd 20 08	lda $0820,x			lda 	hStack,x 					; load high byte in.
.a7c1	71 10		adc ($10),y			adc		(zTemp0),y					; add it
.a7c3	91 10		sta ($10),y			sta 	(zTemp0),y					; write it.
.a7c5	ca		dex				dex 								; throw one away
.a7c6	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a7c9	a8		tay				tay
.a7ca	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a7cd	ca		dex				dex 								; fix up stack
.a7ce	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/dictionary.inc

.a7cf					KernelDictionary:
>a7cf	06					.byte 6
>a7d0	96 a7					.word Memory_WriteWord
>a7d2	00					.byte 0
>a7d3	00					.byte $00
>a7d4	a1					.byte $a1
>a7d5	06					.byte 6
>a7d6	c0 a6					.word Binary_Add
>a7d8	00					.byte 0
>a7d9	00					.byte $00
>a7da	ab					.byte $ab
>a7db	07					.byte 7
>a7dc	b0 a7					.word Memory_AddWord
>a7de	00					.byte 0
>a7df	00					.byte $00
>a7e0	2b a1					.byte $2b,$a1
>a7e2	07					.byte 7
>a7e3	ad a6					.word Unary_Inc1
>a7e5	00					.byte 0
>a7e6	00					.byte $00
>a7e7	2b ab					.byte $2b,$ab
>a7e9	08					.byte 8
>a7ea	a9 a6					.word Unary_Inc2
>a7ec	00					.byte 0
>a7ed	00					.byte $00
>a7ee	2b 2b ab				.byte $2b,$2b,$ab
>a7f1	08					.byte 8
>a7f2	d9 a6					.word Binary_Or
>a7f4	00					.byte 0
>a7f5	00					.byte $00
>a7f6	2b 0f 92				.byte $2b,$0f,$92
>a7f9	06					.byte 6
>a7fa	0f a5					.word System_CompileWord
>a7fc	00					.byte 0
>a7fd	00					.byte $00
>a7fe	ac					.byte $ac
>a7ff	06					.byte 6
>a800	64 a6					.word Unary_Not
>a802	00					.byte 0
>a803	00					.byte $00
>a804	ad					.byte $ad
>a805	07					.byte 7
>a806	b9 a6					.word UnaryDec1
>a808	00					.byte 0
>a809	00					.byte $00
>a80a	2d ad					.byte $2d,$ad
>a80c	08					.byte 8
>a80d	b2 a6					.word Unary_Dec2
>a80f	00					.byte 0
>a810	00					.byte $00
>a811	2d 2d ad				.byte $2d,$2d,$ad
>a814	06					.byte 6
>a815	1b a5					.word Constant_0
>a817	00					.byte 0
>a818	00					.byte $00
>a819	b0					.byte $b0
>a81a	06					.byte 6
>a81b	28 a5					.word Constant_1
>a81d	00					.byte 0
>a81e	00					.byte $00
>a81f	b1					.byte $b1
>a820	07					.byte 7
>a821	53 a6					.word Constant_minus1
>a823	00					.byte 0
>a824	00					.byte $00
>a825	31 ad					.byte $31,$ad
>a827	07					.byte 7
>a828	69 a5					.word Constant_10
>a82a	00					.byte 0
>a82b	00					.byte $00
>a82c	31 b0					.byte $31,$b0
>a82e	08					.byte 8
>a82f	c4 a5					.word Constant_100
>a831	00					.byte 0
>a832	00					.byte $00
>a833	31 30 b0				.byte $31,$30,$b0
>a836	09					.byte 9
>a837	12 a6					.word Constant_1024
>a839	00					.byte 0
>a83a	00					.byte $00
>a83b	31 30 32 b4				.byte $31,$30,$32,$b4
>a83f	07					.byte 7
>a840	76 a5					.word Constant_12
>a842	00					.byte 0
>a843	00					.byte $00
>a844	31 b2					.byte $31,$b2
>a846	08					.byte 8
>a847	d1 a5					.word Constant_127
>a849	00					.byte 0
>a84a	00					.byte $00
>a84b	31 32 b7				.byte $31,$32,$b7
>a84e	08					.byte 8
>a84f	de a5					.word Constant_128
>a851	00					.byte 0
>a852	00					.byte $00
>a853	31 32 b8				.byte $31,$32,$b8
>a856	07					.byte 7
>a857	83 a5					.word Constant_14
>a859	00					.byte 0
>a85a	00					.byte $00
>a85b	31 b4					.byte $31,$b4
>a85d	07					.byte 7
>a85e	90 a5					.word Constant_16
>a860	00					.byte 0
>a861	00					.byte $00
>a862	31 b6					.byte $31,$b6
>a864	08					.byte 8
>a865	7f a6					.word Unary_Times16
>a867	00					.byte 0
>a868	00					.byte $00
>a869	31 36 aa				.byte $31,$36,$aa
>a86c	06					.byte 6
>a86d	35 a5					.word Constant_2
>a86f	00					.byte 0
>a870	00					.byte $00
>a871	b2					.byte $b2
>a872	07					.byte 7
>a873	91 a6					.word Unary_Times2
>a875	00					.byte 0
>a876	00					.byte $00
>a877	32 aa					.byte $32,$aa
>a879	07					.byte 7
>a87a	a0 a6					.word Unary_Div2
>a87c	00					.byte 0
>a87d	00					.byte $00
>a87e	32 af					.byte $32,$af
>a880	09					.byte 9
>a881	1f a6					.word Constant_2048
>a883	00					.byte 0
>a884	00					.byte $00
>a885	32 30 34 b8				.byte $32,$30,$34,$b8
>a889	07					.byte 7
>a88a	9d a5					.word Constant_24
>a88c	00					.byte 0
>a88d	00					.byte $00
>a88e	32 b4					.byte $32,$b4
>a890	08					.byte 8
>a891	eb a5					.word Constant_255
>a893	00					.byte 0
>a894	00					.byte $00
>a895	32 35 b5				.byte $32,$35,$b5
>a898	08					.byte 8
>a899	f8 a5					.word Constant_256
>a89b	00					.byte 0
>a89c	00					.byte $00
>a89d	32 35 b6				.byte $32,$35,$b6
>a8a0	07					.byte 7
>a8a1	aa a5					.word Constant_32
>a8a3	00					.byte 0
>a8a4	00					.byte $00
>a8a5	33 b2					.byte $33,$b2
>a8a7	0a					.byte 10
>a8a8	39 a6					.word Constant_32767
>a8aa	00					.byte 0
>a8ab	00					.byte $00
>a8ac	33 32 37 36 b7				.byte $33,$32,$37,$36,$b7
>a8b1	0a					.byte 10
>a8b2	46 a6					.word Constant_32768
>a8b4	00					.byte 0
>a8b5	00					.byte $00
>a8b6	33 32 37 36 b8				.byte $33,$32,$37,$36,$b8
>a8bb	06					.byte 6
>a8bc	42 a5					.word Constant_4
>a8be	00					.byte 0
>a8bf	00					.byte $00
>a8c0	b4					.byte $b4
>a8c1	07					.byte 7
>a8c2	8b a6					.word Unary_Times4
>a8c4	00					.byte 0
>a8c5	00					.byte $00
>a8c6	34 aa					.byte $34,$aa
>a8c8	07					.byte 7
>a8c9	98 a6					.word Unary_Div4
>a8cb	00					.byte 0
>a8cc	00					.byte $00
>a8cd	34 af					.byte $34,$af
>a8cf	09					.byte 9
>a8d0	2c a6					.word Constant_4096
>a8d2	00					.byte 0
>a8d3	00					.byte $00
>a8d4	34 30 39 b6				.byte $34,$30,$39,$b6
>a8d8	08					.byte 8
>a8d9	05 a6					.word Constant_512
>a8db	00					.byte 0
>a8dc	00					.byte $00
>a8dd	35 31 b2				.byte $35,$31,$b2
>a8e0	06					.byte 6
>a8e1	4f a5					.word Constant_6
>a8e3	00					.byte 0
>a8e4	00					.byte $00
>a8e5	b6					.byte $b6
>a8e6	07					.byte 7
>a8e7	b7 a5					.word Constant_64
>a8e9	00					.byte 0
>a8ea	00					.byte $00
>a8eb	36 b4					.byte $36,$b4
>a8ed	06					.byte 6
>a8ee	5c a5					.word Constant_8
>a8f0	00					.byte 0
>a8f1	00					.byte $00
>a8f2	b8					.byte $b8
>a8f3	07					.byte 7
>a8f4	85 a6					.word Unary_Times8
>a8f6	00					.byte 0
>a8f7	00					.byte $00
>a8f8	38 aa					.byte $38,$aa
>a8fa	09					.byte 9
>a8fb	fa a6					.word Stack_QDup
>a8fd	00					.byte 0
>a8fe	00					.byte $00
>a8ff	3f 04 15 90				.byte $3f,$04,$15,$90
>a903	06					.byte 6
>a904	77 a7					.word Memory_ReadWord
>a906	00					.byte 0
>a907	00					.byte $00
>a908	80					.byte $80
>a909	08					.byte 8
>a90a	6d a6					.word Unary_Abs
>a90c	00					.byte 0
>a90d	00					.byte $00
>a90e	01 02 93				.byte $01,$02,$93
>a911	08					.byte 8
>a912	cd a6					.word Binary_And
>a914	00					.byte 0
>a915	00					.byte $00
>a916	01 0e 84				.byte $01,$0e,$84
>a919	0a					.byte 10
>a91a	01 a5					.word System_Break
>a91c	00					.byte 0
>a91d	00					.byte $00
>a91e	02 12 05 01 8b				.byte $02,$12,$05,$01,$8b
>a923	06					.byte 6
>a924	f4 a4					.word System_ResetStack
>a926	00					.byte 0
>a927	00					.byte $00
>a928	83					.byte $83
>a929	07					.byte 7
>a92a	83 a7					.word Memory_WriteByte
>a92c	00					.byte 0
>a92d	00					.byte $00
>a92e	03 a1					.byte $03,$a1
>a930	07					.byte 7
>a931	03 a5					.word System_CompileByte
>a933	00					.byte 0
>a934	00					.byte $00
>a935	03 ac					.byte $03,$ac
>a937	07					.byte 7
>a938	6e a7					.word Memory_ReadByte
>a93a	00					.byte 0
>a93b	00					.byte $00
>a93c	03 80					.byte $03,$80
>a93e	09					.byte 9
>a93f	fe a4					.word System_ColdStart
>a941	00					.byte 0
>a942	00					.byte $00
>a943	03 0f 0c 84				.byte $03,$0f,$0c,$84
>a947	09					.byte 9
>a948	f1 a6					.word Stack_Drop
>a94a	00					.byte 0
>a94b	00					.byte $00
>a94c	04 12 0f 90				.byte $04,$12,$0f,$90
>a950	08					.byte 8
>a951	03 a7					.word Stack_Dup
>a953	00					.byte 0
>a954	00					.byte $00
>a955	04 15 90				.byte $04,$15,$90
>a958	0b					.byte 11
>a959	72 a6					.word Unary_Negate
>a95b	00					.byte 0
>a95c	00					.byte $00
>a95d	0e 05 07 01 14 85			.byte $0e,$05,$07,$01,$14,$85
>a963	08					.byte 8
>a964	0e a7					.word Stack_Nip
>a966	00					.byte 0
>a967	00					.byte $00
>a968	0e 09 90				.byte $0e,$09,$90
>a96b	07					.byte 7
>a96c	e5 a6					.word Binary_Xor
>a96e	00					.byte 0
>a96f	00					.byte $00
>a970	0f 92					.byte $0f,$92
>a972	09					.byte 9
>a973	10 a7					.word Stack_Over
>a975	00					.byte 0
>a976	00					.byte $00
>a977	0f 16 05 92				.byte $0f,$16,$05,$92
>a97b	09					.byte 9
>a97c	53 a7					.word Stack_Pull
>a97e	00					.byte 0
>a97f	80					.byte $80
>a980	10 15 0c 8c				.byte $10,$15,$0c,$8c
>a984	09					.byte 9
>a985	38 a7					.word Stack_Push
>a987	00					.byte 0
>a988	80					.byte $80
>a989	10 15 13 88				.byte $10,$15,$13,$88
>a98d	0a					.byte 10
>a98e	fa a4					.word System_ResetUserDictionary
>a990	00					.byte 0
>a991	00					.byte $00
>a992	12 05 13 05 94				.byte $12,$05,$13,$05,$94
>a997	09					.byte 9
>a998	20 a7					.word Stack_Swap
>a99a	00					.byte 0
>a99b	00					.byte $00
>a99c	13 17 01 90				.byte $13,$17,$01,$90
>a9a0	00					.byte 0

;******  Return to file: main.asm


;******  End of listing
