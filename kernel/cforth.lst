
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o cforth.prg -L cforth.lst main.asm
; Thu Oct 10 17:26:27 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: compiler/data.asm

=32					STACKSIZE = 32 								; maximum data stack depth
=40					BUFFERSIZE = 40 							; word buffer size
=$00					COL_COMMENT = $00 							; White (comment)
=$40					COL_DEFINE = $40 							; Red (defining word)
=$80					COL_COMPILE = $80 							; Green (compiling word)
=$c0					COL_EXEC = $C0 								; Yellow (executing word)
=$01					DTP_IMMEDIATE = $01 						; Bit 0 type (immediate, cannot be executed)
=$02					DTP_COMPILEONLY = $02 						; Bit 1 type (cannot be execute, only compiled)
>0010					zPage0: .word ?								; temporary page zero pointers
>0012					zPage1: .word ? 							; these must be consecutive.
>0014					freeDictionary: .word ? 					; current end of dictionary address
>0016					freeCode: .word ? 							; next free code byte.
>0018					freeCodeBank: .byte ?						; next free code byte bank (byte())
>0019					newDictRecord: .word ? 						; address of created dictionary record.
>001b					bufferPtr: .word ? 							; buffer pointer
>0800					lStack: .fill STACKSIZE						; low and high byte stack areas. Note that
>0820					hStack: .fill STACKSIZE						; these do not have to be in page zero, it just
>0a00					dictAddr: .word ? 							; these are copied when a search is successful
>0a02					dictBank: .byte ? 							; (must be consecutive)
>0a03					dictType: .byte ?
>0a04					wordType: .byte ?							; type of word in buffer
>0a05					SearchBuffer: .fill BUFFERSIZE				; buffer for word for compiler
>0a2d					CurrentTOS: .word ? 						; current stack top value
>0a2f					CurrentIndex: .byte ? 						; current index value.
>0a30					DefaultStackPointer: .byte ? 				; default value 6502 stack pointer.
>0a31					SCWidth: .byte ? 							; width
>0a32					SCHeight:.byte ?							; height
>0a33					SCX: .byte ?								; screen position
>0a34					SCY: .byte ?
>0a35					SCColour: .byte ?							; drawing colour
>0a36					InputBuffer: .fill BUFFERSIZE 				; input buffer

;******  Return to file: main.asm


;******  Processing file: layouts/simple.inc

=$1000					DictionaryBase = $1000						; Dictionary address
=$2000					CodeSpace = $2000							; Code start position.
=$a000					BuildAddress = $A000 						; where the binary is built

;******  Return to file: main.asm

.a000	ba		tsx				tsx 								; save entry SP
.a001	8e 30 0a	stx $0a30			stx 	DefaultStackPointer
.a004	4c a6 a0	jmp $a0a6			jmp 	ColdStart

;******  Processing file: compiler/dictionary.asm

.a007					DictionaryReset:
.a007	80 06		bra $a00f			bra 	XDictionaryReset
.a009					DictionarySearch:
.a009	80 20		bra $a02b			bra 	XDictionarySearch
.a00b					DictionaryCreate:
.a00b	80 5b		bra $a068			bra 	XDictionaryCreate
.a00d					DictionaryXorTypeByte:
.a00d	80 50		bra $a05f			bra 	XDictionaryXorTypeByte
.a00f					XDictionaryReset:
.a00f	48		pha				pha
.a010	a9 00		lda #$00			lda 	#0 							; reset the next free code byte position.
.a012	85 18		sta $18				sta 	freeCodeBank
.a014	a9 00		lda #$00			lda 	#CodeSpace & $FF
.a016	85 16		sta $16				sta 	freeCode
.a018	a9 20		lda #$20			lda 	#CodeSpace >> 8
.a01a	85 17		sta $17				sta 	freeCode+1
.a01c	a9 00		lda #$00			lda 	#0
.a01e	8d 00 10	sta $1000			sta 	DictionaryBase
.a021	a9 00		lda #$00			lda 	#DictionaryBase & $FF 		; set the next free byte pointer
.a023	85 14		sta $14				sta 	freeDictionary
.a025	a9 10		lda #$10			lda 	#DictionaryBase >> 8
.a027	85 15		sta $15				sta 	freeDictionary+1
.a029	68		pla				pla
.a02a	60		rts				rts
.a02b					XDictionarySearch:
.a02b					_XDSLoop:
.a02b	b2 10		lda ($10)			lda 	(zPage0)					; look at length
.a02d	18		clc				clc 								; clear carry, return CC if failed.
.a02e	f0 2c		beq $a05c			beq		_XDSExit					; exit ?
.a030	a0 05		ldy #$05			ldy 	#5 							; where comparison starts in dictionary
.a032	a2 00		ldx #$00			ldx 	#0 							; comparison starts in SearchBuffer
.a034					_XDSCompare:
.a034	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x 				; compare characters
.a037	d1 10		cmp ($10),y			cmp 	(zPage0),y
.a039	d0 14		bne $a04f			bne 	_XDSNext 					; did not match, try next.
.a03b	e8		inx				inx 								; advance pointers
.a03c	c8		iny				iny
.a03d	0a		asl a				asl 	a 							; shift bit 7 into Carry
.a03e	90 f4		bcc $a034			bcc 	_XDSCompare 				; found it !
.a040	a0 01		ldy #$01			ldy 	#1 							; copy 1,2,3,4 to zPage
.a042					_XDSCopy:
.a042	b1 10		lda ($10),y			lda 	(zPage0),y
.a044	99 ff 09	sta $09ff,y			sta 	dictAddr-1,y
.a047	c8		iny				iny
.a048	c0 05		cpy #$05			cpy 	#5
.a04a	d0 f6		bne $a042			bne 	_XDSCopy
.a04c	38		sec				sec 								; return CS
.a04d	80 0d		bra $a05c			bra 	_XDSExit
.a04f					_XDSNext:
.a04f	18		clc				clc 								; add offset to zPage0
.a050	a5 10		lda $10				lda 	zPage0
.a052	72 10		adc ($10)			adc 	(zPage0)
.a054	85 10		sta $10				sta 	zPage0
.a056	90 d3		bcc $a02b			bcc 	_XDSLoop 					; no carry
.a058	e6 11		inc $11				inc 	zPage0+1 					; carry forward.
.a05a	80 cf		bra $a02b			bra 	_XDSLoop
.a05c					_XDSExit:
.a05c	08		php				php									; switch bank bank, preserving carry.
.a05d	28		plp				plp
.a05e	60		rts				rts
.a05f					XDictionaryXorTypeByte:
.a05f	5a		phy				phy
.a060	a0 04		ldy #$04			ldy 	#4 							; offset to type
.a062	51 19		eor ($19),y			eor 	(newDictRecord),y
.a064	91 19		sta ($19),y			sta 	(newDictRecord),y
.a066	7a		ply				ply
.a067	60		rts				rts
.a068					XDictionaryCreate:
.a068	a5 14		lda $14				lda 	freeDictionary 				; copy address to new dictionary record pointer
.a06a	85 19		sta $19				sta 	newDictRecord
.a06c	a5 15		lda $15				lda 	freeDictionary+1
.a06e	85 1a		sta $1a				sta 	newDictRecord+1
.a070	a0 05		ldy #$05			ldy 	#5 							; copy the name in, also calculates offset
.a072	a2 00		ldx #$00			ldx 	#0
.a074					_XDCCopyName:
.a074	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x 				; copy over name
.a077	91 14		sta ($14),y			sta 	(freeDictionary),y
.a079	e8		inx				inx
.a07a	c8		iny				iny
.a07b	0a		asl a				asl 	a 							; until bit 7 is copied.
.a07c	90 f6		bcc $a074			bcc 	_XDCCopyName
.a07e	98		tya				tya 								; Y is now offset to next
.a07f	92 14		sta ($14)			sta 	(freeDictionary)
.a081	a0 01		ldy #$01			ldy 	#1 							; copy code address & bank in.
.a083	a5 16		lda $16				lda 	freeCode
.a085	91 14		sta ($14),y			sta 	(freeDictionary),y
.a087	c8		iny				iny
.a088	a5 17		lda $17				lda 	freeCode+1
.a08a	91 14		sta ($14),y			sta 	(freeDictionary),y
.a08c	c8		iny				iny
.a08d	a5 18		lda $18				lda 	freeCodeBank
.a08f	91 14		sta ($14),y			sta 	(freeDictionary),y
.a091	c8		iny				iny
.a092	a9 00		lda #$00			lda 	#0 							; set the type byte to zero.
.a094	91 14		sta ($14),y			sta 	(freeDictionary),y
.a096	18		clc				clc 								; adjust freedictionary ptr up
.a097	a5 14		lda $14				lda 	freeDictionary
.a099	72 14		adc ($14)			adc 	(freeDictionary)
.a09b	85 14		sta $14				sta 	freeDictionary
.a09d	90 02		bcc $a0a1			bcc 	_XDCNoCarry
.a09f	e6 15		inc $15				inc 	freeDictionary+1
.a0a1					_XDCNoCarry:
.a0a1	a9 00		lda #$00			lda 	#0 							; write end of dictionary marker
.a0a3	92 14		sta ($14)			sta 	(freeDictionary)
.a0a5	60		rts				rts

;******  Return to file: main.asm

.a0a6					ColdStart:
.a0a6	ae 30 0a	ldx $0a30			ldx 	DefaultStackPointer 		; reset the stack pointer
.a0a9	9a		txs				txs
.a0aa	20 07 a0	jsr $a007			jsr 	DictionaryReset
.a0ad	20 c3 a3	jsr $a3c3			jsr 	System_ResetStack 			; clear stack.
.a0b0	8e 2f 0a	stx $0a2f			stx 	CurrentIndex 				; save that state in 'current' variables
.a0b3	8d 2d 0a	sta $0a2d			sta 	CurrentTOS 					; which is X (stack) and YA (top of stack)
.a0b6	8c 2e 0a	sty $0a2e			sty 	CurrentTOS+1
.a0b9	20 e4 a0	jsr $a0e4			jsr 	XClearScreen
.a0bc	a2 cd		ldx #$cd			ldx 	#TestBuffer & $FF
.a0be	a0 a0		ldy #$a0			ldy 	#TestBuffer >> 8
.a0c0	20 7e a1	jsr $a17e			jsr 	BufferProcess
.a0c3	a9 ff		lda #$ff			lda 	#255
.a0c5					x1:
.a0c5	20 3a a1	jsr $a13a			jsr 	XPrint
.a0c8	3a		dec a				dec 	a
.a0c9	d0 fa		bne $a0c5			bne 	x1
.a0cb	80 fe		bra $a0cb	h1:		bra 	h1

;******  Processing file: testing/buffer.inc

.a0cd					TestBuffer:
>a0cd	f1					 .byte $f1
>a0ce	f3					 .byte $f3
>a0cf	20					 .byte $20
>a0d0	f1					 .byte $f1
>a0d1	f6					 .byte $f6
>a0d2	20					 .byte $20
>a0d3	f1					 .byte $f1
>a0d4	ed					 .byte $ed
>a0d5	20					 .byte $20
>a0d6	f5					 .byte $f5
>a0d7	f1					 .byte $f1
>a0d8	f7					 .byte $f7
>a0d9	20					 .byte $20
>a0da	b1					 .byte $b1
>a0db	b6					 .byte $b6
>a0dc	20					 .byte $20
>a0dd	b4					 .byte $b4
>a0de	b2					 .byte $b2
>a0df	20					 .byte $20
>a0e0	b9					 .byte $b9
>a0e1	b9					 .byte $b9
>a0e2	20					 .byte $20
>a0e3	00					 .byte $00

;******  Return to file: main.asm


;******  Processing file: compiler/macros.inc


;******  Return to file: main.asm


;******  Processing file: system/extern.asm

=$9f20					Vera_Lo = $9F20
=$9f21					Vera_Mid = $9F21
=$9f22					Vera_High = $9F22
=$9f23					Vera_Data = $9F23
.a0e4					XClearScreen:
.a0e4	48		pha				pha
.a0e5	da		phx				phx
.a0e6	5a		phy				phy
.a0e7	a9 0e		lda #$0e			lda 	#14 						; switch to l/c
.a0e9	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a0ec	a9 01		lda #$01			lda 	#$01 						; set fractional scale to 2
.a0ee	8d 20 9f	sta $9f20			sta 	Vera_Lo
.a0f1	9c 21 9f	stz $9f21			stz 	Vera_Mid
.a0f4	a9 1f		lda #$1f			lda 	#$1F
.a0f6	8d 22 9f	sta $9f22			sta 	Vera_High
.a0f9	a9 40		lda #$40			lda		#64
.a0fb	8d 23 9f	sta $9f23			sta 	Vera_Data
.a0fe	8d 23 9f	sta $9f23			sta 	Vera_Data
.a101	a9 28		lda #$28			lda 	#40 						; set size and current draw colour
.a103	8d 31 0a	sta $0a31			sta 	SCWidth
.a106	a9 1e		lda #$1e			lda 	#30
.a108	8d 32 0a	sta $0a32			sta 	SCHeight
.a10b	a9 01		lda #$01			lda 	#1
.a10d	8d 35 0a	sta $0a35			sta 	SCColour
.a110	9c 20 9f	stz $9f20			stz 	Vera_Lo 					; clear memory to spaces
.a113	9c 21 9f	stz $9f21			stz 	Vera_Mid
.a116	a9 10		lda #$10			lda 	#$10
.a118	8d 22 9f	sta $9f22			sta 	Vera_High
.a11b	ad 32 0a	lda $0a32			lda 	SCHeight
.a11e	4a		lsr a				lsr 	a
.a11f	a8		tay				tay
.a120	a2 00		ldx #$00			ldx 	#0
.a122					_XCSLoop:
.a122	a9 20		lda #$20			lda 	#$20
.a124	8d 23 9f	sta $9f23			sta 	Vera_Data
.a127	9c 23 9f	stz $9f23			stz 	Vera_Data
.a12a	ca		dex				dex
.a12b	d0 f5		bne $a122			bne 	_XCSLoop
.a12d	88		dey				dey
.a12e	d0 f2		bne $a122			bne 	_XCSLoop
.a130	7a		ply				ply
.a131	fa		plx				plx
.a132	68		pla				pla 								; fall through to home
.a133					XHomeCursor:
.a133	9c 33 0a	stz $0a33			stz 	SCX
.a136	9c 34 0a	stz $0a34			stz 	SCY
.a139	60		rts				rts
.a13a	48		pha		XPrint:	pha
.a13b	48		pha				pha
.a13c	ad 33 0a	lda $0a33			lda 	SCX 						; 2 bytes / char
.a13f	0a		asl a				asl 	a
.a140	8d 20 9f	sta $9f20			sta 	Vera_Lo 					; low address
.a143	ad 34 0a	lda $0a34			lda 	SCY
.a146	8d 21 9f	sta $9f21			sta 	Vera_Mid 					; mid address
.a149	a9 10		lda #$10			lda 	#$10
.a14b	8d 22 9f	sta $9f22			sta 	Vera_High
.a14e	68		pla				pla 								; characters are PETSCII
.a14f	29 bf		and #$bf			and 	#$BF
.a151	8d 23 9f	sta $9f23			sta		Vera_Data
.a154	ad 35 0a	lda $0a35			lda 	SCColour
.a157	8d 23 9f	sta $9f23			sta 	Vera_Data
.a15a	ee 33 0a	inc $0a33			inc 	SCX 						; one right
.a15d	ad 33 0a	lda $0a33			lda 	SCX
.a160	cd 31 0a	cmp $0a31			cmp 	SCWidth 					; reached RHS
.a163	d0 03		bne $a168			bne 	_XPR0
.a165	20 6a a1	jsr $a16a			jsr 	XNewLine 					; yes, do a new line
.a168					_XPR0:
.a168	68		pla				pla
.a169	60		rts				rts
.a16a					XNewLine:
.a16a	48		pha				pha
.a16b	9c 33 0a	stz $0a33			stz 	SCX 						; start of line
.a16e	ee 34 0a	inc $0a34			inc 	SCY 						; next line down
.a171	ad 34 0a	lda $0a34			lda 	SCY 						; wrap around the bottom.
.a174	cd 32 0a	cmp $0a32			cmp 	SCHeight
.a177	d0 03		bne $a17c			bne 	_XNL0
.a179	9c 34 0a	stz $0a34			stz 	SCY
.a17c	68		pla		_XNL0:	pla
.a17d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: compiler/buffer.asm

.a17e					BufferProcess:
.a17e	84 1c		sty $1c				sty 	bufferPtr+1 				; save buffer pointer
.a180	86 1b		stx $1b				stx 	bufferPtr
.a182					_BPNextWord:
.a182	b2 1b		lda ($1b)			lda 	(bufferPtr) 				; check the next byte
.a184	f0 0e		beq $a194			beq 	_BPExit
.a186	29 3f		and #$3f			and 	#$3F						; is it a space ?
.a188	c9 20		cmp #$20			cmp 	#' '
.a18a	d0 09		bne $a195			bne 	_BPFound 					; no, found a word.
.a18c	e6 1b		inc $1b				inc 	bufferPtr 					; bump pointer over space
.a18e	d0 f2		bne $a182			bne 	_BPNextWord
.a190	e6 1c		inc $1c				inc 	bufferPtr+1
.a192	80 ee		bra $a182			bra 	_BPNextWord
.a194					_BPExit:
.a194	60		rts				rts
.a195					_BPFound:
.a195	b2 1b		lda ($1b)			lda 	(bufferPtr) 				; start by getting the type bits off first character
.a197	29 c0		and #$c0			and 	#$C0						; bits 6 & 7
.a199	8d 04 0a	sta $0a04			sta 	wordType
.a19c	a0 00		ldy #$00			ldy 	#0 							; copy the word.
.a19e					_BPCopy:
.a19e	b1 1b		lda ($1b),y			lda 	(bufferPtr),y 				; copy byte over, dropping the type bits
.a1a0	29 3f		and #$3f			and 	#$3F
.a1a2	99 05 0a	sta $0a05,y			sta 	SearchBuffer,y
.a1a5	c8		iny				iny
.a1a6	c0 40		cpy #$40			cpy 	#64 						; too long a word ?
.a1a8	f0 0a		beq $a1b4			beq 	_BPFoundEnd
.a1aa	b1 1b		lda ($1b),y			lda 	(bufferPtr),y 				; get next
.a1ac	f0 06		beq $a1b4			beq 	_BPFoundEnd 				; if zero, then it's the end of the word
.a1ae	29 3f		and #$3f			and 	#$3F 						; if not space, keep going.
.a1b0	c9 20		cmp #$20			cmp 	#' '
.a1b2	d0 ea		bne $a19e			bne 	_BPCopy
.a1b4					_BPFoundEnd:
.a1b4	b9 04 0a	lda $0a04,y			lda 	SearchBuffer-1,y 			; set bit 7 of the last character
.a1b7	09 80		ora #$80			ora 	#$80
.a1b9	99 04 0a	sta $0a04,y			sta 	SearchBuffer-1,y
.a1bc	98		tya				tya 								; add offset to space/zero to buffer pointer
.a1bd	18		clc				clc
.a1be	65 1b		adc $1b				adc 	bufferPtr
.a1c0	85 1b		sta $1b				sta 	bufferPtr
.a1c2	90 02		bcc $a1c6			bcc 	_BPNoCarry
.a1c4	e6 1c		inc $1c				inc 	bufferPtr+1
.a1c6					_BPNoCarry:
.a1c6	ad 04 0a	lda $0a04			lda 	wordType 					; look at type
.a1c9	c9 00		cmp #$00			cmp 	#COL_COMMENT 			 	; comment (white), just go round again
.a1cb	f0 b5		beq $a182			beq 	_BPNextWord
.a1cd	c9 40		cmp #$40			cmp 	#COL_DEFINE					; word definition (red)
.a1cf	f0 09		beq $a1da			beq 	_BPDefineWord
.a1d1	c9 c0		cmp #$c0			cmp 	#COL_EXEC 					; execute word immediately (yellow)
.a1d3	f0 0a		beq $a1df			beq 	_BPExecute
.a1d5	20 62 a2	jsr $a262			jsr 	BPCompile 					; must be compile (green)
.a1d8	80 a8		bra $a182			bra 	_BPNextWord
.a1da					_BPDefineWord:
.a1da	20 e4 a1	jsr $a1e4			jsr 	BPDefineWord
.a1dd	80 a3		bra $a182			bra 	_BPNextWord
.a1df					_BPExecute:
.a1df	20 fc a1	jsr $a1fc			jsr 	BPExecute
.a1e2	80 9e		bra $a182			bra 	_BPNextWord

;******  Return to file: main.asm


;******  Processing file: compiler/define.asm

.a1e4					BPDefineWord:
.a1e4	20 e2 a2	jsr $a2e2			jsr 	UtilSearchAll 				; does it already exist
.a1e7	b0 04		bcs $a1ed			bcs 	_BPDWDuplicate
.a1e9	20 0b a0	jsr $a00b			jsr 	DictionaryCreate 			; create new word in the dictionary.
.a1ec	60		rts				rts
.a1ed					_BPDWDuplicate:
>a1ed	ff				_		.byte $FF
>a1ee	44 55 50 4c 49 43 41 54				.text "DUPLICATE DEF",0
>a1f6	45 20 44 45 46 00

;******  Return to file: main.asm


;******  Processing file: compiler/execute.asm

.a1fc					BPExecute:
.a1fc	20 e2 a2	jsr $a2e2			jsr 	UtilSearchAll 				; look for it in dictionaries
.a1ff	b0 16		bcs $a217			bcs 	_BPEXFound 					; word found.
.a201	20 fb a2	jsr $a2fb			jsr 	UtilConvertInteger 			; Try as integer
.a204	b0 3d		bcs $a243			bcs 	_BPEXInteger 				; if integer, push on stack, otherwise error
>a206	ff				_		.byte $FF
>a207	55 4e 4b 4e 4f 57 4e 20				.text "UNKNOWN EXECUTE",0
>a20f	45 58 45 43 55 54 45 00
.a217					_BPEXFound:
.a217	2c 03 0a	bit $0a03			bit 	dictType					; check if compile only
.a21a	30 16		bmi $a232			bmi 	_BPEXCompileOnly
.a21c	ae 2f 0a	ldx $0a2f			ldx 	CurrentIndex 				; load the index, and TOS into X and YA
.a21f	ad 2d 0a	lda $0a2d			lda 	CurrentTOS
.a222	ac 2e 0a	ldy $0a2e			ldy 	CurrentTOS+1
.a225	20 40 a2	jsr $a240			jsr 	_BPEXWord 					; call the word code (set by dictionary search)
.a228	8e 2f 0a	stx $0a2f			stx 	CurrentIndex 				; save that state in 'current' variables
.a22b	8d 2d 0a	sta $0a2d			sta 	CurrentTOS 					; which is X (stack) and YA (top of stack)
.a22e	8c 2e 0a	sty $0a2e			sty 	CurrentTOS+1
.a231	60		rts				rts
.a232					_BPEXCompileOnly:
>a232	ff				_		.byte $FF
>a233	43 4f 4d 50 49 4c 45 20				.text "COMPILE ONLY",0
>a23b	4f 4e 4c 59 00
.a240					_BPEXWord:
.a240	6c 00 0a	jmp ($0a00)			jmp 	(dictAddr)
.a243					_BPEXInteger:
.a243	48		pha				pha 								; save constant
.a244	5a		phy				phy
.a245	ae 2f 0a	ldx $0a2f			ldx 	CurrentIndex 				; load the index, and TOS into X and YA
.a248	ad 2d 0a	lda $0a2d			lda 	CurrentTOS
.a24b	ac 2e 0a	ldy $0a2e			ldy 	CurrentTOS+1
.a24e	e8		inx				inx 								; X points to TOS always
.a24f	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a252	98		tya				tya
.a253	9d 20 08	sta $0820,x			sta 	hStack,x
.a256	7a		ply				ply 								; restore constant
.a257	68		pla				pla
.a258	8e 2f 0a	stx $0a2f			stx 	CurrentIndex 				; save that state in 'current' variables
.a25b	8d 2d 0a	sta $0a2d			sta 	CurrentTOS 					; which is X (stack) and YA (top of stack)
.a25e	8c 2e 0a	sty $0a2e			sty 	CurrentTOS+1
.a261	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: compiler/compile.asm

.a262					BPCompile:
.a262	20 e2 a2	jsr $a2e2			jsr 	UtilSearchAll 				; look for it in dictionaries
.a265	b0 1d		bcs $a284			bcs 	_BPCOFound 					; word found.
.a267	20 fb a2	jsr $a2fb			jsr 	UtilConvertInteger 			; is it a number
.a26a	b0 1c		bcs $a288			bcs 	_BPCONumber 				; if so, do a number.
.a26c	ad 05 0a	lda $0a05			lda 	SearchBuffer 				; is it a quoted string ?
.a26f	c9 22		cmp #$22			cmp 	#'"'
.a271	f0 3f		beq $a2b2			beq 	_BPCOString
>a273	ff				_		.byte $FF
>a274	55 4e 4b 4e 4f 57 4e 20				.text "UNKNOWN COMPILE",0
>a27c	43 4f 4d 50 49 4c 45 00
.a284					_BPCOFound:
.a284	20 59 a3	jsr $a359			jsr 	UtilCompileCall 			; compile call to currently found element
.a287	60		rts				rts
.a288					_BPCONumber:
.a288	c0 00		cpy #$00			cpy 	#0 							; check if 8 bit constant
.a28a	f0 14		beq $a2a0			beq 	_BPCOShort
.a28c	48		pha				pha 								; 16 bit constant
.a28d	5a		phy				phy
.a28e	a9 20		lda #$20			lda 	#$20 						; compile call
.a290	20 78 a3	jsr $a378			jsr 	UtilCompileByte
.a293	a9 81		lda #$81			lda 	#Constant_2Byte & $FF
.a295	a0 a3		ldy #$a3			ldy 	#Constant_2Byte >> 8
.a297	20 6c a3	jsr $a36c			jsr 	UtilCompileWord
.a29a	7a		ply				ply
.a29b	68		pla				pla
.a29c	20 6c a3	jsr $a36c			jsr 	UtilCompileWord 			; compile the actual word
.a29f	60		rts				rts
.a2a0					_BPCOShort:
.a2a0	48		pha				pha
.a2a1	a9 20		lda #$20			lda 	#$20 						; compile call
.a2a3	20 78 a3	jsr $a378			jsr 	UtilCompileByte
.a2a6	a9 a1		lda #$a1			lda 	#Constant_1Byte & $FF
.a2a8	a0 a3		ldy #$a3			ldy 	#Constant_1Byte >> 8
.a2aa	20 6c a3	jsr $a36c			jsr 	UtilCompileWord
.a2ad	68		pla				pla
.a2ae	20 78 a3	jsr $a378			jsr 	UtilCompileByte 			; compile the actual byte
.a2b1	60		rts				rts
.a2b2					_BPCOString:
.a2b2	a9 20		lda #$20			lda 	#$20 						; compile call
.a2b4	20 78 a3	jsr $a378			jsr 	UtilCompileByte
.a2b7	a9 ba		lda #$ba			lda 	#Constant_String & $FF
.a2b9	a0 a3		ldy #$a3			ldy 	#Constant_String >> 8
.a2bb	20 6c a3	jsr $a36c			jsr 	UtilCompileWord
.a2be	da		phx				phx 								; find length of string.
.a2bf	a2 00		ldx #$00			ldx 	#0
.a2c1					_BPCOSFindLength:
.a2c1	e8		inx				inx
.a2c2	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x
.a2c5	10 fa		bpl $a2c1			bpl 	_BPCOSFindLength
.a2c7	8a		txa				txa
.a2c8	20 78 a3	jsr $a378			jsr 	UtilCompileByte
.a2cb	a2 01		ldx #$01			ldx 	#1 							; compile the string
.a2cd					_BPCOSCompile:
.a2cd	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x
.a2d0	c9 5f		cmp #$5f			cmp 	#"_" 						; map _ to space
.a2d2	d0 02		bne $a2d6			bne		_BPCOSNotSpace
.a2d4	a9 20		lda #$20			lda 	#" "
.a2d6					_BPCOSNotSpace:
.a2d6	20 78 a3	jsr $a378			jsr 	UtilCompileByte
.a2d9	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x
.a2dc	0a		asl a				asl 	a
.a2dd	e8		inx				inx
.a2de	90 ed		bcc $a2cd			bcc 	_BPCOSCompile
.a2e0	fa		plx				plx
.a2e1	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: compiler/utilities.asm

.a2e2					UtilSearchAll:
.a2e2	a9 00		lda #$00			lda 	#DictionaryBase & $FF		; search the user dictionary
.a2e4	a2 10		ldx #$10			ldx 	#DictionaryBase >> 8
.a2e6	85 10		sta $10				sta 	zPage0
.a2e8	86 11		stx $11				stx 	zPage0+1
.a2ea	20 09 a0	jsr $a009			jsr 	DictionarySearch
.a2ed	b0 0b		bcs $a2fa			bcs 	_BSAExit
.a2ef	a9 9e		lda #$9e			lda 	#KernelDictionary & $FF		; search the system dictionary
.a2f1	a2 a6		ldx #$a6			ldx 	#KernelDictionary >> 8
.a2f3	85 10		sta $10				sta 	zPage0
.a2f5	86 11		stx $11				stx 	zPage0+1
.a2f7	20 09 a0	jsr $a009			jsr 	DictionarySearch
.a2fa					_BSAExit:
.a2fa	60		rts				rts
.a2fb					UtilConvertInteger:
.a2fb	64 10		stz $10				stz 	zPage0 						; zero the result
.a2fd	64 11		stz $11				stz 	zPage0+1
.a2ff	a2 ff		ldx #$ff			ldx 	#255 						; start position-1
.a301					_BCILoop:
.a301	e8		inx				inx 								; next character
.a302	20 3e a3	jsr $a33e			jsr 	UtilTimes10 				; zPage0 x 10
.a305	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x 				; look at character
.a308	29 7f		and #$7f			and 	#$7F  						; drop end character bit
.a30a	c9 30		cmp #$30			cmp 	#'0'						; is it an integer character
.a30c	90 2e		bcc $a33c			bcc 	_BCIFail 					; if not, then exit.
.a30e	c9 3a		cmp #$3a			cmp 	#'9'+1
.a310	b0 2a		bcs $a33c			bcs 	_BCIFail
.a312	29 0f		and #$0f			and 	#15 						; now constant 0-9
.a314	18		clc				clc 								; add to current
.a315	65 10		adc $10				adc 	zPage0
.a317	85 10		sta $10				sta 	zPage0
.a319	90 02		bcc $a31d			bcc 	_BCINoCarry
.a31b	e6 11		inc $11				inc 	zPage0+1
.a31d					_BCINoCarry:
.a31d	bd 05 0a	lda $0a05,x			lda 	SearchBuffer,x 				; check if was last character
.a320	30 14		bmi $a336			bmi 	_BCISucceed 				; if so, then it's okay.
.a322	bd 06 0a	lda $0a06,x			lda 	SearchBuffer+1,x 			; is the next char -+End
.a325	c9 ad		cmp #$ad			cmp 	#"-"+$80
.a327	d0 d8		bne $a301			bne 	_BCILoop 					; no, go round again.
.a329					_BCINegateExit:
.a329	38		sec				sec
.a32a	a9 00		lda #$00			lda 	#0 							; do the arithmetic adjustment
.a32c	e5 10		sbc $10				sbc 	zPage0
.a32e	85 10		sta $10				sta 	zPage0
.a330	a9 00		lda #$00			lda 	#0
.a332	e5 11		sbc $11				sbc 	zPage0+1
.a334	85 11		sta $11				sta 	zPage0+1
.a336					_BCISucceed:
.a336	38		sec				sec
.a337	a5 10		lda $10				lda 	zPage0
.a339	a4 11		ldy $11				ldy 	zPage0+1
.a33b	60		rts				rts
.a33c					_BCIFail:
.a33c	18		clc				clc
.a33d	60		rts				rts
.a33e					UtilTimes10:
.a33e	a5 11		lda $11				lda 	zPage0+1 					; save in YA
.a340	a8		tay				tay
.a341	a5 10		lda $10				lda 	zPage0
.a343	06 10		asl $10				asl 	zPage0 						; x 4
.a345	26 11		rol $11				rol 	zPage0+1
.a347	06 10		asl $10				asl 	zPage0
.a349	26 11		rol $11				rol 	zPage0+1
.a34b	65 10		adc $10				adc 	zPage0 						; add YA value gives x 5
.a34d	85 10		sta $10				sta 	zPage0
.a34f	98		tya				tya
.a350	65 11		adc $11				adc 	zPage0+1
.a352	85 11		sta $11				sta 	zPage0+1
.a354	06 10		asl $10				asl 	zPage0	 					; x 10
.a356	26 11		rol $11				rol 	zPage0+1
.a358	60		rts				rts
.a359					UtilCompileCall:
.a359	48		pha				pha
.a35a	5a		phy				phy
.a35b	a9 20		lda #$20			lda 	#$20 						; JSR
.a35d	20 78 a3	jsr $a378			jsr 	UtilCompileByte
.a360	ad 00 0a	lda $0a00			lda 	dictAddr
.a363	ac 01 0a	ldy $0a01			ldy 	dictAddr+1
.a366	20 6c a3	jsr $a36c			jsr 	UtilCompileWord
.a369	7a		ply				ply
.a36a	68		pla				pla
.a36b	60		rts				rts
.a36c					UtilCompileWord:
.a36c	48		pha				pha
.a36d	5a		phy				phy
.a36e	20 78 a3	jsr $a378			jsr 	UtilCompileByte
.a371	98		tya				tya
.a372	20 78 a3	jsr $a378			jsr 	UtilCompileByte
.a375	7a		ply				ply
.a376	68		pla				pla
.a377	60		rts				rts
.a378					UtilCompileByte:
.a378	92 16		sta ($16)			sta 	(freeCode)
.a37a	e6 16		inc $16				inc 	freeCode
.a37c	d0 02		bne $a380			bne 	_UCBNoCarry
.a37e	e6 17		inc $17				inc 	freeCode+1
.a380					_UCBNoCarry:
.a380	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: compiler/support.asm

.a381					Constant_2Byte:
.a381	e8		inx				inx 								; X points to TOS always
.a382	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a385	98		tya				tya
.a386	9d 20 08	sta $0820,x			sta 	hStack,x
.a389	68		pla				pla 								; get return address into YA
.a38a	7a		ply				ply
.a38b	1a		inc a				inc 	a
.a38c	d0 01		bne $a38f			bne		*+3
.a38e	c8		iny				iny
.a38f	85 10		sta $10				sta 	zPage0 						; save address in zero page
.a391	84 11		sty $11				sty 	zPage0+1
.a393	1a		inc a				inc 	a
.a394	d0 01		bne $a397			bne		*+3
.a396	c8		iny				iny
.a397	5a		phy				phy 								; push it back
.a398	48		pha				pha
.a399	a0 01		ldy #$01			ldy 	#1 							; load the constant into YA
.a39b	b1 10		lda ($10),y			lda 	(zPage0),y
.a39d	a8		tay				tay
.a39e	b2 10		lda ($10)			lda 	(zPage0)
.a3a0	60		rts				rts
.a3a1					Constant_1Byte:
.a3a1	e8		inx				inx 								; X points to TOS always
.a3a2	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a3a5	98		tya				tya
.a3a6	9d 20 08	sta $0820,x			sta 	hStack,x
.a3a9	68		pla				pla 								; get return address into YA
.a3aa	7a		ply				ply
.a3ab	1a		inc a				inc 	a
.a3ac	d0 01		bne $a3af			bne		*+3
.a3ae	c8		iny				iny
.a3af	85 10		sta $10				sta 	zPage0 						; save address in zero page
.a3b1	84 11		sty $11				sty 	zPage0+1
.a3b3	5a		phy				phy 								; push it back
.a3b4	48		pha				pha
.a3b5	b2 10		lda ($10)			lda 	(zPage0)
.a3b7	a0 00		ldy #$00			ldy 	#0
.a3b9	60		rts				rts
.a3ba					Constant_String:
.a3ba	e8		inx				inx 								; X points to TOS always
.a3bb	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a3be	98		tya				tya
.a3bf	9d 20 08	sta $0820,x			sta 	hStack,x
.a3c2	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: vocabulary/system.voc

.a3c3					System_ResetStack:
.a3c3	a2 ff		ldx #$ff			ldx 	#-1 						; reset the stack pointer
.a3c5	a9 00		lda #$00			lda 	#0 							; clear the tos value held in YA
.a3c7	a8		tay				tay
.a3c8	60		rts				rts
.a3c9					System_ResetUserDictionary:
.a3c9	20 07 a0	jsr $a007			jsr 	DictionaryReset 			; reset the dictionary and code pointer.
.a3cc	60		rts				rts
.a3cd					System_ColdStart:
.a3cd	4c a6 a0	jmp $a0a6			jmp 	ColdStart
.a3d0					System_Break:
>a3d0	ff						.byte 	$FF
.a3d1	60		rts				rts
.a3d2					System_CompileByte:
.a3d2	20 78 a3	jsr $a378			jsr 	UtilCompileByte
.a3d5	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a3d8	a8		tay				tay
.a3d9	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a3dc	ca		dex				dex 								; fix up stack
.a3dd	60		rts				rts
.a3de					System_CompileWord:
.a3de	20 6c a3	jsr $a36c			jsr 	UtilCompileWord
.a3e1	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a3e4	a8		tay				tay
.a3e5	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a3e8	ca		dex				dex 								; fix up stack
.a3e9	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/constants.voc

.a3ea					Constant_0:
.a3ea	e8		inx				inx 								; X points to TOS always
.a3eb	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a3ee	98		tya				tya
.a3ef	9d 20 08	sta $0820,x			sta 	hStack,x
.a3f2	a9 00		lda #$00			lda 	#(0) & $FF					; load new constant into YA
.a3f4	a0 00		ldy #$00			ldy 	#(0) >> 8
.a3f6	60		rts				rts
.a3f7					Constant_1:
.a3f7	e8		inx				inx 								; X points to TOS always
.a3f8	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a3fb	98		tya				tya
.a3fc	9d 20 08	sta $0820,x			sta 	hStack,x
.a3ff	a9 01		lda #$01			lda 	#(1) & $FF					; load new constant into YA
.a401	a0 00		ldy #$00			ldy 	#(1) >> 8
.a403	60		rts				rts
.a404					Constant_2:
.a404	e8		inx				inx 								; X points to TOS always
.a405	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a408	98		tya				tya
.a409	9d 20 08	sta $0820,x			sta 	hStack,x
.a40c	a9 02		lda #$02			lda 	#(2) & $FF					; load new constant into YA
.a40e	a0 00		ldy #$00			ldy 	#(2) >> 8
.a410	60		rts				rts
.a411					Constant_4:
.a411	e8		inx				inx 								; X points to TOS always
.a412	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a415	98		tya				tya
.a416	9d 20 08	sta $0820,x			sta 	hStack,x
.a419	a9 04		lda #$04			lda 	#(4) & $FF					; load new constant into YA
.a41b	a0 00		ldy #$00			ldy 	#(4) >> 8
.a41d	60		rts				rts
.a41e					Constant_6:
.a41e	e8		inx				inx 								; X points to TOS always
.a41f	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a422	98		tya				tya
.a423	9d 20 08	sta $0820,x			sta 	hStack,x
.a426	a9 06		lda #$06			lda 	#(6) & $FF					; load new constant into YA
.a428	a0 00		ldy #$00			ldy 	#(6) >> 8
.a42a	60		rts				rts
.a42b					Constant_8:
.a42b	e8		inx				inx 								; X points to TOS always
.a42c	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a42f	98		tya				tya
.a430	9d 20 08	sta $0820,x			sta 	hStack,x
.a433	a9 08		lda #$08			lda 	#(8) & $FF					; load new constant into YA
.a435	a0 00		ldy #$00			ldy 	#(8) >> 8
.a437	60		rts				rts
.a438					Constant_10:
.a438	e8		inx				inx 								; X points to TOS always
.a439	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a43c	98		tya				tya
.a43d	9d 20 08	sta $0820,x			sta 	hStack,x
.a440	a9 0a		lda #$0a			lda 	#(10) & $FF					; load new constant into YA
.a442	a0 00		ldy #$00			ldy 	#(10) >> 8
.a444	60		rts				rts
.a445					Constant_12:
.a445	e8		inx				inx 								; X points to TOS always
.a446	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a449	98		tya				tya
.a44a	9d 20 08	sta $0820,x			sta 	hStack,x
.a44d	a9 0c		lda #$0c			lda 	#(12) & $FF					; load new constant into YA
.a44f	a0 00		ldy #$00			ldy 	#(12) >> 8
.a451	60		rts				rts
.a452					Constant_14:
.a452	e8		inx				inx 								; X points to TOS always
.a453	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a456	98		tya				tya
.a457	9d 20 08	sta $0820,x			sta 	hStack,x
.a45a	a9 0e		lda #$0e			lda 	#(14) & $FF					; load new constant into YA
.a45c	a0 00		ldy #$00			ldy 	#(14) >> 8
.a45e	60		rts				rts
.a45f					Constant_16:
.a45f	e8		inx				inx 								; X points to TOS always
.a460	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a463	98		tya				tya
.a464	9d 20 08	sta $0820,x			sta 	hStack,x
.a467	a9 10		lda #$10			lda 	#(16) & $FF					; load new constant into YA
.a469	a0 00		ldy #$00			ldy 	#(16) >> 8
.a46b	60		rts				rts
.a46c					Constant_24:
.a46c	e8		inx				inx 								; X points to TOS always
.a46d	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a470	98		tya				tya
.a471	9d 20 08	sta $0820,x			sta 	hStack,x
.a474	a9 18		lda #$18			lda 	#(24) & $FF					; load new constant into YA
.a476	a0 00		ldy #$00			ldy 	#(24) >> 8
.a478	60		rts				rts
.a479					Constant_32:
.a479	e8		inx				inx 								; X points to TOS always
.a47a	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a47d	98		tya				tya
.a47e	9d 20 08	sta $0820,x			sta 	hStack,x
.a481	a9 20		lda #$20			lda 	#(32) & $FF					; load new constant into YA
.a483	a0 00		ldy #$00			ldy 	#(32) >> 8
.a485	60		rts				rts
.a486					Constant_64:
.a486	e8		inx				inx 								; X points to TOS always
.a487	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a48a	98		tya				tya
.a48b	9d 20 08	sta $0820,x			sta 	hStack,x
.a48e	a9 40		lda #$40			lda 	#(64) & $FF					; load new constant into YA
.a490	a0 00		ldy #$00			ldy 	#(64) >> 8
.a492	60		rts				rts
.a493					Constant_100:
.a493	e8		inx				inx 								; X points to TOS always
.a494	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a497	98		tya				tya
.a498	9d 20 08	sta $0820,x			sta 	hStack,x
.a49b	a9 64		lda #$64			lda 	#(100) & $FF					; load new constant into YA
.a49d	a0 00		ldy #$00			ldy 	#(100) >> 8
.a49f	60		rts				rts
.a4a0					Constant_127:
.a4a0	e8		inx				inx 								; X points to TOS always
.a4a1	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a4a4	98		tya				tya
.a4a5	9d 20 08	sta $0820,x			sta 	hStack,x
.a4a8	a9 7f		lda #$7f			lda 	#(127) & $FF					; load new constant into YA
.a4aa	a0 00		ldy #$00			ldy 	#(127) >> 8
.a4ac	60		rts				rts
.a4ad					Constant_128:
.a4ad	e8		inx				inx 								; X points to TOS always
.a4ae	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a4b1	98		tya				tya
.a4b2	9d 20 08	sta $0820,x			sta 	hStack,x
.a4b5	a9 80		lda #$80			lda 	#(128) & $FF					; load new constant into YA
.a4b7	a0 00		ldy #$00			ldy 	#(128) >> 8
.a4b9	60		rts				rts
.a4ba					Constant_255:
.a4ba	e8		inx				inx 								; X points to TOS always
.a4bb	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a4be	98		tya				tya
.a4bf	9d 20 08	sta $0820,x			sta 	hStack,x
.a4c2	a9 ff		lda #$ff			lda 	#(255) & $FF					; load new constant into YA
.a4c4	a0 00		ldy #$00			ldy 	#(255) >> 8
.a4c6	60		rts				rts
.a4c7					Constant_256:
.a4c7	e8		inx				inx 								; X points to TOS always
.a4c8	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a4cb	98		tya				tya
.a4cc	9d 20 08	sta $0820,x			sta 	hStack,x
.a4cf	a9 00		lda #$00			lda 	#(256) & $FF					; load new constant into YA
.a4d1	a0 01		ldy #$01			ldy 	#(256) >> 8
.a4d3	60		rts				rts
.a4d4					Constant_512:
.a4d4	e8		inx				inx 								; X points to TOS always
.a4d5	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a4d8	98		tya				tya
.a4d9	9d 20 08	sta $0820,x			sta 	hStack,x
.a4dc	a9 00		lda #$00			lda 	#(512) & $FF					; load new constant into YA
.a4de	a0 02		ldy #$02			ldy 	#(512) >> 8
.a4e0	60		rts				rts
.a4e1					Constant_1024:
.a4e1	e8		inx				inx 								; X points to TOS always
.a4e2	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a4e5	98		tya				tya
.a4e6	9d 20 08	sta $0820,x			sta 	hStack,x
.a4e9	a9 00		lda #$00			lda 	#(1024) & $FF					; load new constant into YA
.a4eb	a0 04		ldy #$04			ldy 	#(1024) >> 8
.a4ed	60		rts				rts
.a4ee					Constant_2048:
.a4ee	e8		inx				inx 								; X points to TOS always
.a4ef	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a4f2	98		tya				tya
.a4f3	9d 20 08	sta $0820,x			sta 	hStack,x
.a4f6	a9 00		lda #$00			lda 	#(2048) & $FF					; load new constant into YA
.a4f8	a0 08		ldy #$08			ldy 	#(2048) >> 8
.a4fa	60		rts				rts
.a4fb					Constant_4096:
.a4fb	e8		inx				inx 								; X points to TOS always
.a4fc	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a4ff	98		tya				tya
.a500	9d 20 08	sta $0820,x			sta 	hStack,x
.a503	a9 00		lda #$00			lda 	#(4096) & $FF					; load new constant into YA
.a505	a0 10		ldy #$10			ldy 	#(4096) >> 8
.a507	60		rts				rts
.a508					Constant_32767:
.a508	e8		inx				inx 								; X points to TOS always
.a509	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a50c	98		tya				tya
.a50d	9d 20 08	sta $0820,x			sta 	hStack,x
.a510	a9 ff		lda #$ff			lda 	#(32767) & $FF					; load new constant into YA
.a512	a0 7f		ldy #$7f			ldy 	#(32767) >> 8
.a514	60		rts				rts
.a515					Constant_32768:
.a515	e8		inx				inx 								; X points to TOS always
.a516	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a519	98		tya				tya
.a51a	9d 20 08	sta $0820,x			sta 	hStack,x
.a51d	a9 00		lda #$00			lda 	#(32768) & $FF					; load new constant into YA
.a51f	a0 80		ldy #$80			ldy 	#(32768) >> 8
.a521	60		rts				rts
.a522					Constant_minus1:
.a522	e8		inx				inx 								; X points to TOS always
.a523	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a526	98		tya				tya
.a527	9d 20 08	sta $0820,x			sta 	hStack,x
.a52a	a9 ff		lda #$ff			lda 	#(65535) & $FF					; load new constant into YA
.a52c	a0 ff		ldy #$ff			ldy 	#(65535) >> 8
.a52e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: vocabulary/unary.voc

.a52f					Unary_BSwap:
.a52f	48		pha				pha 								; save A
.a530	98		tya				tya 								; Y->A
.a531	7a		ply				ply 								; old A->Y
.a532	60		rts				rts
.a533					Unary_Not:
.a533	49 ff		eor #$ff			eor 	#$FF
.a535	48		pha				pha
.a536	98		tya				tya
.a537	49 ff		eor #$ff			eor 	#$FF
.a539	a8		tay				tay
.a53a	68		pla				pla
.a53b	60		rts				rts
.a53c					Unary_Abs:
.a53c	c0 00		cpy #$00			cpy 	#0 							; do -ve code if -ve
.a53e	30 01		bmi $a541			bmi 	Unary_Negate
.a540	60		rts				rts
.a541					Unary_Negate:
.a541	49 ff		eor #$ff			eor 	#$FF
.a543	48		pha				pha
.a544	98		tya				tya
.a545	49 ff		eor #$ff			eor 	#$FF
.a547	a8		tay				tay
.a548	68		pla				pla
.a549	1a		inc a				inc 	a
.a54a	d0 01		bne $a54d			bne		*+3
.a54c	c8		iny				iny
.a54d	60		rts				rts
.a54e					Unary_Times16:
.a54e	0a		asl a				asl 	a 							; shift low left
.a54f	48		pha				pha
.a550	98		tya				tya 								; shift high left
.a551	2a		rol a				rol 	a
.a552	a8		tay				tay
.a553	68		pla				pla
.a554					Unary_Times8:
.a554	0a		asl a				asl 	a 							; shift low left
.a555	48		pha				pha
.a556	98		tya				tya 								; shift high left
.a557	2a		rol a				rol 	a
.a558	a8		tay				tay
.a559	68		pla				pla
.a55a					Unary_Times4:
.a55a	0a		asl a				asl 	a 							; shift low left
.a55b	48		pha				pha
.a55c	98		tya				tya 								; shift high left
.a55d	2a		rol a				rol 	a
.a55e	a8		tay				tay
.a55f	68		pla				pla
.a560					Unary_Times2:
.a560	0a		asl a				asl 	a 							; shift low left
.a561	48		pha				pha
.a562	98		tya				tya 								; shift high left
.a563	2a		rol a				rol 	a
.a564	a8		tay				tay
.a565	68		pla				pla
.a566	60		rts				rts
.a567					Unary_Div4:
.a567	48		pha				pha 								; save low
.a568	98		tya				tya 								; get high, shift MSB into C
.a569	0a		asl a				asl 	a
.a56a	98		tya				tya 								; get high again, rotate C in
.a56b	6a		ror a				ror 	a
.a56c	a8		tay				tay
.a56d	68		pla				pla 								; restore low and rotate right
.a56e	6a		ror a				ror 	a
.a56f					Unary_Div2:
.a56f	48		pha				pha 								; save low
.a570	98		tya				tya 								; get high, shift MSB into C
.a571	0a		asl a				asl 	a
.a572	98		tya				tya 								; get high again, rotate C in
.a573	6a		ror a				ror 	a
.a574	a8		tay				tay
.a575	68		pla				pla 								; restore low and rotate right
.a576	6a		ror a				ror 	a
.a577	60		rts				rts
.a578					Unary_Inc2:
.a578	1a		inc a				inc 	a
.a579	d0 01		bne $a57c			bne		*+3
.a57b	c8		iny				iny
.a57c					Unary_Inc1:
.a57c	1a		inc a				inc 	a
.a57d	d0 01		bne $a580			bne		*+3
.a57f	c8		iny				iny
.a580	60		rts				rts
.a581					Unary_Dec2:
.a581	38		sec				sec
.a582	e9 02		sbc #$02			sbc 	#2
.a584	b0 01		bcs $a587			bcs		*+3
.a586	88		dey				dey
.a587	60		rts				rts
.a588					UnaryDec1:
.a588	38		sec				sec
.a589	e9 01		sbc #$01			sbc 	#1
.a58b	b0 01		bcs $a58e			bcs		*+3
.a58d	88		dey				dey
.a58e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: vocabulary/binary.voc

.a58f					Binary_Add:
.a58f	18		clc				clc
.a590	7d 00 08	adc $0800,x			adc 	lStack,x 					; do the LSB
.a593	48		pha				pha 								; save the result
.a594	98		tya				tya 								; do the MSB
.a595	7d 20 08	adc $0820,x			adc 	hStack,x
.a598	a8		tay				tay
.a599	68		pla				pla 								; restore
.a59a	ca		dex				dex 								; pop off the stack.
.a59b	60		rts				rts
.a59c					Binary_And:
.a59c	3d 00 08	and $0800,x			and 	lStack,x 					; do the LSB
.a59f	48		pha				pha 								; save the result
.a5a0	98		tya				tya 								; do the MSB
.a5a1	3d 20 08	and $0820,x			and 	hStack,x
.a5a4	a8		tay				tay
.a5a5	68		pla				pla 								; restore
.a5a6	ca		dex				dex 								; pop off the stack.
.a5a7	60		rts				rts
.a5a8					Binary_Or:
.a5a8	1d 00 08	ora $0800,x			ora 	lStack,x 					; do the LSB
.a5ab	48		pha				pha 								; save the result
.a5ac	98		tya				tya 								; do the MSB
.a5ad	1d 20 08	ora $0820,x			ora 	hStack,x
.a5b0	a8		tay				tay
.a5b1	68		pla				pla 								; restore
.a5b2	ca		dex				dex 								; pop off the stack.
.a5b3	60		rts				rts
.a5b4					Binary_Xor:
.a5b4	5d 00 08	eor $0800,x			eor 	lStack,x 					; do the LSB
.a5b7	48		pha				pha 								; save the result
.a5b8	98		tya				tya 								; do the MSB
.a5b9	5d 20 08	eor $0820,x			eor 	hStack,x
.a5bc	a8		tay				tay
.a5bd	68		pla				pla 								; restore
.a5be	ca		dex				dex 								; pop off the stack.
.a5bf	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: vocabulary/stack.voc

.a5c0					Stack_Drop:
.a5c0	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a5c3	a8		tay				tay
.a5c4	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a5c7	ca		dex				dex 								; fix up stack
.a5c8	60		rts				rts
.a5c9					Stack_QDup:
.a5c9	c9 00		cmp #$00			cmp 	#0
.a5cb	d0 05		bne $a5d2			bne 	Stack_Dup
.a5cd	c0 00		cpy #$00			cpy 	#0
.a5cf	d0 01		bne $a5d2			bne 	Stack_Dup
.a5d1	60		rts				rts
.a5d2					Stack_Dup:
.a5d2	48		pha				pha
.a5d3	e8		inx				inx 								; X points to TOS always
.a5d4	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a5d7	98		tya				tya
.a5d8	9d 20 08	sta $0820,x			sta 	hStack,x
.a5db	68		pla				pla
.a5dc	60		rts				rts
.a5dd					Stack_Nip:
.a5dd	ca		dex				dex
.a5de	60		rts				rts
.a5df					Stack_Over:
.a5df	e8		inx				inx 								; X points to TOS always
.a5e0	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a5e3	98		tya				tya
.a5e4	9d 20 08	sta $0820,x			sta 	hStack,x
.a5e7	bd 1f 08	lda $081f,x			lda 	hStack-1,x 					; copy 2nd element to YA
.a5ea	a8		tay				tay
.a5eb	bd ff 07	lda $07ff,x			lda 	lStack-1,x
.a5ee	60		rts				rts
.a5ef					Stack_Swap:
.a5ef	85 10		sta $10				sta 	zPage0 						; save A
.a5f1	84 11		sty $11				sty 	zPage0+1 					; save Y
.a5f3	bd 00 08	lda $0800,x			lda 	lStack,x 					; push 2nd A on stack
.a5f6	48		pha				pha
.a5f7	bd 20 08	lda $0820,x			lda 	hStack,x 					; get 2nd Y
.a5fa	a8		tay				tay
.a5fb	a5 10		lda $10				lda 	zPage0 						; first A
.a5fd	9d 00 08	sta $0800,x			sta 	lStack,x
.a600	a5 11		lda $11				lda 	zPage0+1					; first Y
.a602	9d 20 08	sta $0820,x			sta 	hStack,x
.a605	68		pla				pla 								; restore 2nd A
.a606	60		rts				rts
.a607					Stack_Push:
.a607	85 10		sta $10				sta 	zPage0 						; save TOS
.a609	84 11		sty $11				sty 	zPage0+1
.a60b	86 12		stx $12				stx 	zPage1 						; save X
.a60d	fa		plx				plx 								; return address into YX
.a60e	7a		ply				ply
.a60f	a5 10		lda $10				lda 	zPage0						; push LSB
.a611	48		pha				pha
.a612	a5 11		lda $11				lda 	zPage0+1 					; push MSB
.a614	48		pha				pha
.a615	5a		phy				phy 								; save address back.
.a616	da		phx				phx
.a617	a6 12		ldx $12				ldx 	zPage1 						; restore X
.a619	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a61c	a8		tay				tay
.a61d	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a620	ca		dex				dex 								; fix up stack
.a621	60		rts				rts
.a622					Stack_Pull:
.a622	e8		inx				inx 								; X points to TOS always
.a623	9d 00 08	sta $0800,x			sta 	lStack,x 					; save current YA on stack
.a626	98		tya				tya
.a627	9d 20 08	sta $0820,x			sta 	hStack,x
.a62a	68		pla				pla 								; get return address
.a62b	85 10		sta $10				sta 	zPage0
.a62d	7a		ply				ply
.a62e	68		pla				pla 								; get MSB
.a62f	85 13		sta $13				sta 	zPage1+1
.a631	68		pla				pla  								; get LSB
.a632	85 12		sta $12				sta 	zPage1
.a634	5a		phy				phy 								; restore return address.
.a635	a5 10		lda $10				lda 	zPage0
.a637	48		pha				pha
.a638	a5 12		lda $12				lda 	zPage1 						; set up YA
.a63a	a4 13		ldy $13				ldy 	zPage1+1
.a63c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: vocabulary/memory.voc

.a63d					Memory_ReadByte:
.a63d	85 10		sta $10				sta 	zPage0 						; save address
.a63f	84 11		sty $11				sty 	zPage0+1
.a641	b2 10		lda ($10)			lda 	(zPage0) 					; load byte in.
.a643	a0 00		ldy #$00			ldy 	#0
.a645	60		rts				rts
.a646					Memory_ReadWord:
.a646	85 10		sta $10				sta 	zPage0 						; save address
.a648	84 11		sty $11				sty 	zPage0+1
.a64a	a0 01		ldy #$01			ldy 	#1							; get high byte
.a64c	b1 10		lda ($10),y			lda 	(zPage0),y
.a64e	a8		tay				tay
.a64f	b2 10		lda ($10)			lda 	(zPage0) 					; load low byte in.
.a651	60		rts				rts
.a652					Memory_WriteByte:
.a652	85 10		sta $10				sta 	zPage0 						; save address
.a654	84 11		sty $11				sty 	zPage0+1
.a656	bd 00 08	lda $0800,x			lda 	lStack,x 					; load byte in.
.a659	92 10		sta ($10)			sta 	(zPage0)					; write it.
.a65b	ca		dex				dex 								; throw one away
.a65c	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a65f	a8		tay				tay
.a660	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a663	ca		dex				dex 								; fix up stack
.a664	60		rts				rts
.a665					Memory_WriteWord:
.a665	85 10		sta $10				sta 	zPage0 						; save address
.a667	84 11		sty $11				sty 	zPage0+1
.a669	bd 20 08	lda $0820,x			lda 	hStack,x 					; load high byte in.
.a66c	a0 01		ldy #$01			ldy 	#1
.a66e	91 10		sta ($10),y			sta 	(zPage0),y					; write it.
.a670	bd 00 08	lda $0800,x			lda 	lStack,x 					; load low byte in.
.a673	92 10		sta ($10)			sta 	(zPage0)					; write it.
.a675	ca		dex				dex 								; throw one away
.a676	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a679	a8		tay				tay
.a67a	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a67d	ca		dex				dex 								; fix up stack
.a67e	60		rts				rts
.a67f					Memory_AddWord:
.a67f	85 10		sta $10				sta 	zPage0 						; save address
.a681	84 11		sty $11				sty 	zPage0+1
.a683	18		clc				clc
.a684	bd 00 08	lda $0800,x			lda 	lStack,x 					; load low byte in.
.a687	72 10		adc ($10)			adc 	(zPage0)					; add it
.a689	92 10		sta ($10)			sta 	(zPage0)					; write it.
.a68b	a0 01		ldy #$01			ldy 	#1
.a68d	bd 20 08	lda $0820,x			lda 	hStack,x 					; load high byte in.
.a690	71 10		adc ($10),y			adc		(zPage0),y					; add it
.a692	91 10		sta ($10),y			sta 	(zPage0),y					; write it.
.a694	ca		dex				dex 								; throw one away
.a695	bd 20 08	lda $0820,x			lda 	hStack,x					; high -> Y
.a698	a8		tay				tay
.a699	bd 00 08	lda $0800,x			lda 	lStack,x 					; low -> A
.a69c	ca		dex				dex 								; fix up stack
.a69d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/dictionary.inc

.a69e					KernelDictionary:
>a69e	06					.byte 6
>a69f	65 a6					.word Memory_WriteWord
>a6a1	00					.byte 0
>a6a2	00					.byte $00
>a6a3	a1					.byte $a1
>a6a4	06					.byte 6
>a6a5	8f a5					.word Binary_Add
>a6a7	00					.byte 0
>a6a8	00					.byte $00
>a6a9	ab					.byte $ab
>a6aa	07					.byte 7
>a6ab	7f a6					.word Memory_AddWord
>a6ad	00					.byte 0
>a6ae	00					.byte $00
>a6af	2b a1					.byte $2b,$a1
>a6b1	07					.byte 7
>a6b2	7c a5					.word Unary_Inc1
>a6b4	00					.byte 0
>a6b5	00					.byte $00
>a6b6	2b ab					.byte $2b,$ab
>a6b8	08					.byte 8
>a6b9	78 a5					.word Unary_Inc2
>a6bb	00					.byte 0
>a6bc	00					.byte $00
>a6bd	2b 2b ab				.byte $2b,$2b,$ab
>a6c0	08					.byte 8
>a6c1	a8 a5					.word Binary_Or
>a6c3	00					.byte 0
>a6c4	00					.byte $00
>a6c5	2b 0f 92				.byte $2b,$0f,$92
>a6c8	06					.byte 6
>a6c9	de a3					.word System_CompileWord
>a6cb	00					.byte 0
>a6cc	00					.byte $00
>a6cd	ac					.byte $ac
>a6ce	06					.byte 6
>a6cf	33 a5					.word Unary_Not
>a6d1	00					.byte 0
>a6d2	00					.byte $00
>a6d3	ad					.byte $ad
>a6d4	07					.byte 7
>a6d5	88 a5					.word UnaryDec1
>a6d7	00					.byte 0
>a6d8	00					.byte $00
>a6d9	2d ad					.byte $2d,$ad
>a6db	08					.byte 8
>a6dc	81 a5					.word Unary_Dec2
>a6de	00					.byte 0
>a6df	00					.byte $00
>a6e0	2d 2d ad				.byte $2d,$2d,$ad
>a6e3	06					.byte 6
>a6e4	ea a3					.word Constant_0
>a6e6	00					.byte 0
>a6e7	00					.byte $00
>a6e8	b0					.byte $b0
>a6e9	06					.byte 6
>a6ea	f7 a3					.word Constant_1
>a6ec	00					.byte 0
>a6ed	00					.byte $00
>a6ee	b1					.byte $b1
>a6ef	07					.byte 7
>a6f0	22 a5					.word Constant_minus1
>a6f2	00					.byte 0
>a6f3	00					.byte $00
>a6f4	31 ad					.byte $31,$ad
>a6f6	07					.byte 7
>a6f7	38 a4					.word Constant_10
>a6f9	00					.byte 0
>a6fa	00					.byte $00
>a6fb	31 b0					.byte $31,$b0
>a6fd	08					.byte 8
>a6fe	93 a4					.word Constant_100
>a700	00					.byte 0
>a701	00					.byte $00
>a702	31 30 b0				.byte $31,$30,$b0
>a705	09					.byte 9
>a706	e1 a4					.word Constant_1024
>a708	00					.byte 0
>a709	00					.byte $00
>a70a	31 30 32 b4				.byte $31,$30,$32,$b4
>a70e	07					.byte 7
>a70f	45 a4					.word Constant_12
>a711	00					.byte 0
>a712	00					.byte $00
>a713	31 b2					.byte $31,$b2
>a715	08					.byte 8
>a716	a0 a4					.word Constant_127
>a718	00					.byte 0
>a719	00					.byte $00
>a71a	31 32 b7				.byte $31,$32,$b7
>a71d	08					.byte 8
>a71e	ad a4					.word Constant_128
>a720	00					.byte 0
>a721	00					.byte $00
>a722	31 32 b8				.byte $31,$32,$b8
>a725	07					.byte 7
>a726	52 a4					.word Constant_14
>a728	00					.byte 0
>a729	00					.byte $00
>a72a	31 b4					.byte $31,$b4
>a72c	07					.byte 7
>a72d	5f a4					.word Constant_16
>a72f	00					.byte 0
>a730	00					.byte $00
>a731	31 b6					.byte $31,$b6
>a733	08					.byte 8
>a734	4e a5					.word Unary_Times16
>a736	00					.byte 0
>a737	00					.byte $00
>a738	31 36 aa				.byte $31,$36,$aa
>a73b	06					.byte 6
>a73c	04 a4					.word Constant_2
>a73e	00					.byte 0
>a73f	00					.byte $00
>a740	b2					.byte $b2
>a741	07					.byte 7
>a742	60 a5					.word Unary_Times2
>a744	00					.byte 0
>a745	00					.byte $00
>a746	32 aa					.byte $32,$aa
>a748	07					.byte 7
>a749	6f a5					.word Unary_Div2
>a74b	00					.byte 0
>a74c	00					.byte $00
>a74d	32 af					.byte $32,$af
>a74f	09					.byte 9
>a750	ee a4					.word Constant_2048
>a752	00					.byte 0
>a753	00					.byte $00
>a754	32 30 34 b8				.byte $32,$30,$34,$b8
>a758	07					.byte 7
>a759	6c a4					.word Constant_24
>a75b	00					.byte 0
>a75c	00					.byte $00
>a75d	32 b4					.byte $32,$b4
>a75f	08					.byte 8
>a760	ba a4					.word Constant_255
>a762	00					.byte 0
>a763	00					.byte $00
>a764	32 35 b5				.byte $32,$35,$b5
>a767	08					.byte 8
>a768	c7 a4					.word Constant_256
>a76a	00					.byte 0
>a76b	00					.byte $00
>a76c	32 35 b6				.byte $32,$35,$b6
>a76f	07					.byte 7
>a770	79 a4					.word Constant_32
>a772	00					.byte 0
>a773	00					.byte $00
>a774	33 b2					.byte $33,$b2
>a776	0a					.byte 10
>a777	08 a5					.word Constant_32767
>a779	00					.byte 0
>a77a	00					.byte $00
>a77b	33 32 37 36 b7				.byte $33,$32,$37,$36,$b7
>a780	0a					.byte 10
>a781	15 a5					.word Constant_32768
>a783	00					.byte 0
>a784	00					.byte $00
>a785	33 32 37 36 b8				.byte $33,$32,$37,$36,$b8
>a78a	06					.byte 6
>a78b	11 a4					.word Constant_4
>a78d	00					.byte 0
>a78e	00					.byte $00
>a78f	b4					.byte $b4
>a790	07					.byte 7
>a791	5a a5					.word Unary_Times4
>a793	00					.byte 0
>a794	00					.byte $00
>a795	34 aa					.byte $34,$aa
>a797	07					.byte 7
>a798	67 a5					.word Unary_Div4
>a79a	00					.byte 0
>a79b	00					.byte $00
>a79c	34 af					.byte $34,$af
>a79e	09					.byte 9
>a79f	fb a4					.word Constant_4096
>a7a1	00					.byte 0
>a7a2	00					.byte $00
>a7a3	34 30 39 b6				.byte $34,$30,$39,$b6
>a7a7	08					.byte 8
>a7a8	d4 a4					.word Constant_512
>a7aa	00					.byte 0
>a7ab	00					.byte $00
>a7ac	35 31 b2				.byte $35,$31,$b2
>a7af	06					.byte 6
>a7b0	1e a4					.word Constant_6
>a7b2	00					.byte 0
>a7b3	00					.byte $00
>a7b4	b6					.byte $b6
>a7b5	07					.byte 7
>a7b6	86 a4					.word Constant_64
>a7b8	00					.byte 0
>a7b9	00					.byte $00
>a7ba	36 b4					.byte $36,$b4
>a7bc	06					.byte 6
>a7bd	2b a4					.word Constant_8
>a7bf	00					.byte 0
>a7c0	00					.byte $00
>a7c1	b8					.byte $b8
>a7c2	07					.byte 7
>a7c3	54 a5					.word Unary_Times8
>a7c5	00					.byte 0
>a7c6	00					.byte $00
>a7c7	38 aa					.byte $38,$aa
>a7c9	09					.byte 9
>a7ca	c9 a5					.word Stack_QDup
>a7cc	00					.byte 0
>a7cd	00					.byte $00
>a7ce	3f 04 15 90				.byte $3f,$04,$15,$90
>a7d2	06					.byte 6
>a7d3	46 a6					.word Memory_ReadWord
>a7d5	00					.byte 0
>a7d6	00					.byte $00
>a7d7	80					.byte $80
>a7d8	08					.byte 8
>a7d9	3c a5					.word Unary_Abs
>a7db	00					.byte 0
>a7dc	00					.byte $00
>a7dd	01 02 93				.byte $01,$02,$93
>a7e0	08					.byte 8
>a7e1	9c a5					.word Binary_And
>a7e3	00					.byte 0
>a7e4	00					.byte $00
>a7e5	01 0e 84				.byte $01,$0e,$84
>a7e8	0a					.byte 10
>a7e9	d0 a3					.word System_Break
>a7eb	00					.byte 0
>a7ec	00					.byte $00
>a7ed	02 12 05 01 8b				.byte $02,$12,$05,$01,$8b
>a7f2	06					.byte 6
>a7f3	c3 a3					.word System_ResetStack
>a7f5	00					.byte 0
>a7f6	00					.byte $00
>a7f7	83					.byte $83
>a7f8	07					.byte 7
>a7f9	52 a6					.word Memory_WriteByte
>a7fb	00					.byte 0
>a7fc	00					.byte $00
>a7fd	03 a1					.byte $03,$a1
>a7ff	07					.byte 7
>a800	d2 a3					.word System_CompileByte
>a802	00					.byte 0
>a803	00					.byte $00
>a804	03 ac					.byte $03,$ac
>a806	07					.byte 7
>a807	3d a6					.word Memory_ReadByte
>a809	00					.byte 0
>a80a	00					.byte $00
>a80b	03 80					.byte $03,$80
>a80d	09					.byte 9
>a80e	cd a3					.word System_ColdStart
>a810	00					.byte 0
>a811	00					.byte $00
>a812	03 0f 0c 84				.byte $03,$0f,$0c,$84
>a816	09					.byte 9
>a817	c0 a5					.word Stack_Drop
>a819	00					.byte 0
>a81a	00					.byte $00
>a81b	04 12 0f 90				.byte $04,$12,$0f,$90
>a81f	08					.byte 8
>a820	d2 a5					.word Stack_Dup
>a822	00					.byte 0
>a823	00					.byte $00
>a824	04 15 90				.byte $04,$15,$90
>a827	0b					.byte 11
>a828	41 a5					.word Unary_Negate
>a82a	00					.byte 0
>a82b	00					.byte $00
>a82c	0e 05 07 01 14 85			.byte $0e,$05,$07,$01,$14,$85
>a832	08					.byte 8
>a833	dd a5					.word Stack_Nip
>a835	00					.byte 0
>a836	00					.byte $00
>a837	0e 09 90				.byte $0e,$09,$90
>a83a	07					.byte 7
>a83b	b4 a5					.word Binary_Xor
>a83d	00					.byte 0
>a83e	00					.byte $00
>a83f	0f 92					.byte $0f,$92
>a841	09					.byte 9
>a842	df a5					.word Stack_Over
>a844	00					.byte 0
>a845	00					.byte $00
>a846	0f 16 05 92				.byte $0f,$16,$05,$92
>a84a	09					.byte 9
>a84b	22 a6					.word Stack_Pull
>a84d	00					.byte 0
>a84e	80					.byte $80
>a84f	10 15 0c 8c				.byte $10,$15,$0c,$8c
>a853	09					.byte 9
>a854	07 a6					.word Stack_Push
>a856	00					.byte 0
>a857	80					.byte $80
>a858	10 15 13 88				.byte $10,$15,$13,$88
>a85c	0a					.byte 10
>a85d	c9 a3					.word System_ResetUserDictionary
>a85f	00					.byte 0
>a860	00					.byte $00
>a861	12 05 13 05 94				.byte $12,$05,$13,$05,$94
>a866	09					.byte 9
>a867	ef a5					.word Stack_Swap
>a869	00					.byte 0
>a86a	00					.byte $00
>a86b	13 17 01 90				.byte $13,$17,$01,$90
>a86f	00					.byte 0

;******  Return to file: main.asm


;******  End of listing
